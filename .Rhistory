return( PDERawZDeltas )
}
# Main functions
# Function to create a bar plot of mean Zdelta values from iterations
create_barplot_mean_z_deltas <-
function( meanImputationZDeltaInsertedMissings, BestUniMultivariateMethodPerDataset, overallBestZDelta ) {
rowmeanImputationZDeltaInsertedMissings <- apply( meanImputationZDeltaInsertedMissings, 1, function( x ) median( x, na.rm = TRUE ) )
BarplotMeanZDeltas <- create_barplot( data = rowmeanImputationZDeltaInsertedMissings,
BestUniMultivariateMethodPerDataset,
title = "zDelta (means)",
ylab = "zDelta",
annotate_methods = c( "Best poisoned", "Best univariate", "Best" ),
overallBestZDelta = overallBestZDelta ) +
scale_y_continuous( trans = "log10" )
return( BarplotMeanZDeltas )
}
# Function to create a sina plot of raw Zdelta values
create_z_deltas_per_var_plot <- function( meanImputationZDeltaInsertedMissings ) {
rowmeanImputationZDeltaInsertedMissings <- apply( meanImputationZDeltaInsertedMissings, 1, function( x ) median( x, na.rm = TRUE ) )
df <- data.frame( reshape2::melt( rowmeanImputationZDeltaInsertedMissings ) )
df$Method <- gsub( " imputed|Imp", "", rownames( df ) )
MethodsOrder <- df$Method[order( df$value )]
zDeltaP <- data.frame( meanImputationZDeltaInsertedMissings )
zDeltaP$Method <- gsub( ' imputed|Imp', '', rownames( zDeltaP ) )
zDeltaP$Method <- factor( zDeltaP$Method, levels = MethodsOrder )
zDeltaP$calibratingMtd <- ifelse( zDeltaP$Method %in% calibrating_imputation_methods, "Calibrating methods", "Methods" )
zDeltaP$calibratingMtd <- factor( zDeltaP$calibratingMtd, levels = c( "Calibrating methods", "Methods" ) )
zDelta_long <- reshape2::melt( zDeltaP )
zDelta_long$variable <- gsub( "ZDelta_", "", zDelta_long$variable )
zDelta_long$Failed <- ifelse( is.na( zDelta_long$value ), 0.01, NA )
ZDeltaPerVarPlot <-
ggplot( data = zDelta_long, aes( x = Method, y = value, color = variable ) ) +
geom_violin( ) +
geom_jitter( width = 0.05 ) +
ggh4x::facet_grid2( . ~ calibratingMtd, scales = "free", space = "free_x", independent = "y" ) +
theme_light( ) +
theme( axis.text.x = element_text( angle = 90, vjust = 0.5, hjust = 1 ),
legend.position = "top", legend.direction = "horizontal",
legend.background = element_rect( fill = alpha( "white", 0.5 ) ) ) +
labs( title = "Mean ZDelta per variable", x = NULL, y = "Normalized error", color = "Variable" ) +
# stat_summary( aes( y = value, ymax = after_stat( y ), ymin = after_stat( y ) ),
#               fun = median, geom = "errorbar", color = "red", width = 0.3 ) +
guides( colour = guide_legend( nrow = 1 ) ) +
scale_y_continuous( trans = "log10" )
if ( !sum( is.na( zDelta_long$Failed ) ) == nrow( zDelta_long ) ) {
ZDeltaPerVarPlot <- ZDeltaPerVarPlot + geom_point( aes( x = Method, y = Failed ), pch = 4, color = "black" )
}
return( ZDeltaPerVarPlot )
}
# Create ZDelta plots
pZdeltasPlotAvgerage <- create_barplot_mean_z_deltas(
meanImputationZDeltaInsertedMissings = Zdeltas$meanImputationZDeltaInsertedMissings,
BestUniMultivariateMethodPerDataset = BestUniMultivariateMethodPerDataset,
overallBestZDelta = overallBestZDelta
)
pZdeltasPlotAvgerage
pZdeltasPerVar <- create_z_deltas_per_var_plot(
meanImputationZDeltaInsertedMissings = Zdeltas$meanImputationZDeltaInsertedMissings
)
rowmeanImputationZDeltaInsertedMissings <- apply( meanImputationZDeltaInsertedMissings, 1, function( x ) median( x, na.rm = TRUE ) )
df <- data.frame( reshape2::melt( rowmeanImputationZDeltaInsertedMissings ) )
df <- data.frame( reshape2::melt( rowmeanImputationZDeltaInsertedMissings ) )
df$Method <- gsub( " imputed|Imp", "", rownames( df ) )
MethodsOrder <- df$Method[order( df$value )]
zDeltaP <- data.frame( meanImputationZDeltaInsertedMissings )
zDeltaP$Method <- gsub( ' imputed|Imp', '', rownames( zDeltaP ) )
zDeltaP$Method <- factor( zDeltaP$Method, levels = MethodsOrder )
zDeltaP$calibratingMtd <- ifelse( zDeltaP$Method %in% calibrating_imputation_methods, "Calibrating methods", "Methods" )
zDeltaP$calibratingMtd <- factor( zDeltaP$calibratingMtd, levels = c( "Calibrating methods", "Methods" ) )
zDelta_long <- reshape2::melt( zDeltaP )
zDeltaP
zDelta_long <- reshape2::melt( zDeltaP, id.vars = "calibratingMtd")
zDelta_long <- reshape2::melt( zDeltaP, id.vars = "calibratingMtd")
zDelta_long <- reshape2::melt( zDeltaP )
# Helper function for data frame creation for bar plot
generate_barplot_df <-
function( data, BestUniMultivariateMethodPerDataset,
annotate_methods, overallBestZDelta ) {
df <- data.frame( reshape2::melt( data ) )
df$Method <- gsub( " imputed|Imp", "", rownames( df ) )
MethodsOrder <- df$Method[order( df$value )]
df$Method <- factor( df$Method, levels = MethodsOrder )
df$Failed <- ifelse( is.na( df$value ), 0.01, NA )
df$color <- "Multivariate"
df$color[df$Method %in% gsub( " imputed", "", poisoned_imputation_methods )] <- "Poisoned"
df$color[df$Method %in% gsub( " imputed", "", univariate_imputation_methods )] <- "Univariate"
df$color[df$Method %in% gsub( " imputed", "", calibrating_imputation_methods )] <- "Calibrating"
df$color <- factor( df$color, levels = c( "Multivariate", "Calibrating", "Poisoned", "Univariate" ) )
names( myColorsZDelta ) <- levels( df$color )
df$calibratingMtd <- ifelse( df$color == "Calibrating", "Calibrating methods", "Methods" )
df$calibratingMtd <- factor( df$calibratingMtd, levels = c( "Calibrating methods", "Methods" ) )
minmaxPoisoned <- min( df$value[df$color %in% "Poisoned"], na.rm = TRUE )
minmaxUnivariate <- min( df$value[df$color %in% "Univariate"], na.rm = TRUE )
if ( overallBestZDelta == FALSE ) {
minBest <- df$value[df$Method == BestUniMultivariateMethodPerDataset]
} else {
minBest <- min( df$value[df$Method %in% c( univariate_imputation_methods, multivariate_imputation_methods )], na.rm = TRUE )
annotate_methods[3] <- "Best non-poisoned"
}
dfAnnotate <- data.frame( Methods = annotate_methods,
y = c( minmaxPoisoned, minmaxUnivariate, minBest ),
x = c( 3, 3, ifelse( length( df$Method %in% c( univariate_imputation_methods, multivariate_imputation_methods ) ) > 7, 7, 2 ) ),
color = c( "salmon", "orange", "darkgreen" ) )
return( list(
dfBars = df,
dfAnnotate = dfAnnotate,
myColorsZDelta = myColorsZDelta
)
)
}
# Helper function for data frame creation for PDE plot
generate_PDE_plot_df <- function( multivarZDeltas, univarZDeltas, poisonedZDeltas, calibratingZDeltas ) {
vZDeltas <- c( multivarZDeltas, univarZDeltas, poisonedZDeltas, calibratingZDeltas )
namesvZDeltas <- c( rep( "Multivariate", length( multivarZDeltas ) ),
rep( "Univariate", length( univarZDeltas ) ),
rep( "Poisoned", length( poisonedZDeltas ) ),
rep( "Calibrating", length( calibratingZDeltas ) ) )
df4plot_long <- cbind.data.frame( Category = namesvZDeltas, Zdelta = vZDeltas )
df4plot_long <- na.omit( df4plot_long )
# Calculate PDE xy
ParetoDistributions <- lapply( unique( df4plot_long$Category ), function( Category ) {
Pareto <- DataVisualizations::ParetoDensityEstimation( Data = df4plot_long$Zdelta[df4plot_long$Category == Category], PlotIt = FALSE )
dfPareto <- data.frame( Category = Category, x = Pareto$kernels, PDE = Pareto$paretoDensity )
return( dfPareto )
} )
dfParetoAll <- do.call( rbind.data.frame, ParetoDistributions )
dfParetoAll$Category <- factor( dfParetoAll$Category, levels = c( "Multivariate", "Calibrating", "Poisoned", "Univariate" ) )
return( dfParetoAll )
}
# Function to create a bare ZDealta bar plot
create_barplot <- function( data, BestUniMultivariateMethodPerDataset,
title, ylab, annotate_methods,
overallBestZDelta = overallBestZDelta ) {
# Data frame creation
df <- generate_barplot_df(
data = data,
BestUniMultivariateMethodPerDataset = BestUniMultivariateMethodPerDataset,
annotate_methods = annotate_methods,
overallBestZDelta = overallBestZDelta
)
df4plot_long <- df$dfBars
dfAnnotate <- df$dfAnnotate
myColorsZDelta <- df$myColorsZDelta
# Plotting
BarplotMeans <-
ggplot( data = df4plot_long, aes( x = Method, y = value ) ) +
geom_bar( aes( fill = color ), stat = "identity", position = "dodge", alpha = 0.5 ) +
ggh4x::facet_grid2( . ~ calibratingMtd, scales = "free", space = "free_x", independent = "y" ) +
theme_light( ) +
theme(
axis.text.x = element_text( angle = 90, vjust = 0.5, hjust = 1 ),
legend.position = c( 0.9, 0.7 ),
legend.background = element_rect( fill = alpha( "white", 0.5 ) )
) +
labs( title = title, y = ylab, x = NULL, fill = "Imputation" ) +
scale_fill_manual( values = myColorsZDelta ) +
geom_hline( yintercept = dfAnnotate$y[1], color = "salmon", linetype = "dashed" ) +
geom_hline( yintercept = dfAnnotate$y[2], color = "orange", linetype = "dotdash" ) +
geom_hline( yintercept = dfAnnotate$y[3], color = "darkgreen" ) +
ggrepel::geom_text_repel( data = dfAnnotate, aes( label = Methods, x = x, y = y, color = color ), inherit.aes = FALSE ) +
scale_color_manual( values = myColorsZDelta )
if ( !sum( is.na( df4plot_long$Failed ) ) == nrow( df4plot_long ) ) {
BarplotMeans <- BarplotMeans + geom_point( aes( x = Method, y = Failed ), pch = 4 )
}
return( BarplotMeans )
}
# Function to create a bare ZDelta PDE plot
create_z_delta_PDE_plot <- function( dfParetoAll ) {
names( myColorsZDelta ) <- levels( dfParetoAll$Category )
PDERawZDeltas <-
ggplot( ) +
geom_line( data = dfParetoAll[dfParetoAll$Category %in% c( "Multivariate", "Univariate" ),], aes( x = x, y = PDE, color = Category ) ) +
theme_light( ) +
theme(
legend.position = "bottom",
legend.direction = "horizontal",
legend.background = element_rect( colour = "transparent", fill = ggplot2::alpha( "white", 0.4 ) )
) +
labs( title = "PDE of raw Zdelta values", x = "Data", y = "PDE" ) +
scale_color_manual( values = myColorsZDelta )
return( PDERawZDeltas )
}
# Main functions
# Function to create a bar plot of mean Zdelta values from iterations
create_barplot_mean_z_deltas <-
function( meanImputationZDeltaInsertedMissings, BestUniMultivariateMethodPerDataset, overallBestZDelta ) {
rowmeanImputationZDeltaInsertedMissings <- apply( meanImputationZDeltaInsertedMissings, 1, function( x ) median( x, na.rm = TRUE ) )
BarplotMeanZDeltas <- create_barplot( data = rowmeanImputationZDeltaInsertedMissings,
BestUniMultivariateMethodPerDataset,
title = "zDelta (means)",
ylab = "zDelta",
annotate_methods = c( "Best poisoned", "Best univariate", "Best" ),
overallBestZDelta = overallBestZDelta ) +
scale_y_continuous( trans = "log10" )
return( BarplotMeanZDeltas )
}
# Function to create a sina plot of raw Zdelta values
create_z_deltas_per_var_plot <- function( meanImputationZDeltaInsertedMissings ) {
rowmeanImputationZDeltaInsertedMissings <- apply( meanImputationZDeltaInsertedMissings, 1, function( x ) median( x, na.rm = TRUE ) )
df <- data.frame( reshape2::melt( rowmeanImputationZDeltaInsertedMissings ) )
df$Method <- gsub( " imputed|Imp", "", rownames( df ) )
MethodsOrder <- df$Method[order( df$value )]
zDeltaP <- data.frame( meanImputationZDeltaInsertedMissings )
zDeltaP$Method <- gsub( ' imputed|Imp', '', rownames( zDeltaP ) )
zDeltaP$Method <- factor( zDeltaP$Method, levels = MethodsOrder )
zDeltaP$calibratingMtd <- ifelse( zDeltaP$Method %in% calibrating_imputation_methods, "Calibrating methods", "Methods" )
zDeltaP$calibratingMtd <- factor( zDeltaP$calibratingMtd, levels = c( "Calibrating methods", "Methods" ) )
zDelta_long <- reshape2::melt( zDeltaP )
zDelta_long$variable <- gsub( "ZDelta_", "", zDelta_long$variable )
zDelta_long$Failed <- ifelse( is.na( zDelta_long$value ), 0.01, NA )
ZDeltaPerVarPlot <-
ggplot( data = zDelta_long, aes( x = Method, y = value, color = variable ) ) +
geom_violin( ) +
geom_jitter( width = 0.05 ) +
ggh4x::facet_grid2( . ~ calibratingMtd, scales = "free", space = "free_x", independent = "y" ) +
theme_light( ) +
theme( axis.text.x = element_text( angle = 90, vjust = 0.5, hjust = 1 ),
legend.position = "top", legend.direction = "horizontal",
legend.background = element_rect( fill = alpha( "white", 0.5 ) ) ) +
labs( title = "Mean ZDelta per variable", x = NULL, y = "Normalized error", color = "Variable" ) +
# stat_summary( aes( y = value, ymax = after_stat( y ), ymin = after_stat( y ) ),
#               fun = median, geom = "errorbar", color = "red", width = 0.3 ) +
guides( colour = guide_legend( nrow = 1 ) ) +
scale_y_continuous( trans = "log10" )
if ( !sum( is.na( zDelta_long$Failed ) ) == nrow( zDelta_long ) ) {
ZDeltaPerVarPlot <- ZDeltaPerVarPlot + geom_point( aes( x = Method, y = Failed ), pch = 4, color = "black" )
}
return( ZDeltaPerVarPlot )
}
library(opImputation)
seed = 100
nIter = 20
nProc = nProc <- round( ( parallel::detectCores( ) )  ) - 2
probMissing = 0.1
PValueThresholdForMetrics = 0.1
ImputationRepetitions = 20
Data = iris[,1:4]
PlotIt = TRUE
pfctMtdsInABC = FALSE
univariate_imputation_methods <- c( "median", "mean", "mode", "rSample" )
poisoned_imputation_methods <- c( "plus", "plusminus", "factor" )
calibrating_imputation_methods <- c("tinyNoise_0.000001", "tinyNoise_0.00001", "tinyNoise_0.0001", "tinyNoise_0.001", "tinyNoise_0.01",
"tinyNoise_0.05", "tinyNoise_0.1", "tinyNoise_0.2", "tinyNoise_0.5", "tinyNoise_1")
multivariate_imputation_methods <- c( "bag", "bag_repeated",
"rf_mice", "rf_mice_repeated", "rf_missForest", "rf_missForest_repeated", "miceRanger", "miceRanger_repeated",
"cart", "cart_repeated",
"linear",
"pmm", "pmm_repeated",
"knn3", "knn5", "knn7", "knn9", "knn10",
"ameliaImp", "ameliaImp_repeated",
"miImp"
)
all_imputation_methods <- c( univariate_imputation_methods,
poisoned_imputation_methods,
calibrating_imputation_methods,
multivariate_imputation_methods
)
ImputationMethods =all_imputation_methods
radius <- 5
totalNr <- 100
nVars <- 3
dfXmatrix <- NULL
jitterAmount <- 0.3
# "Two linear xy data sets forming an X" =
set.seed( seed )
x <- jitter( seq( from = 0, to = 10, length.out = totalNr ), amount = jitterAmount )
set.seed( seed + 1 )
y1 <- jitter( 1 * x, amount = jitterAmount )
set.seed( seed + 2 )
y2 <- jitter( -1 * x + 10, amount = jitterAmount )
dfXmatrixTwolinearXY <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# "UniformRandom3VarIndependent"
set.seed( seed )
x <- runif( totalNr, min = 0, max = 10 )
set.seed( seed + 1 )
y1 <- runif( totalNr, min = 0, max = 10 )
set.seed( seed + 2 )
y2 <- runif( totalNr, min = 0, max = 10 )
dfXmatrixIndependent <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# "UniformRandom3VarDependent" = {
set.seed( seed )
x <- runif( totalNr, min = 0, max = 10 )
set.seed( seed )
y1 <- runif( totalNr, min = 0, max = 10 )
set.seed( seed )
y2 <- runif( totalNr, min = 0, max = 10 )
dfXmatrixDependent <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# "AlmostIdenticalValues" = {
set.seed( seed )
x <- jitter(rep(1, totalNr), amount = 0.0001 * 1)
set.seed( seed + 1 )
y1 <- jitter(rep(1, totalNr), amount = 0.0001 * 1)
set.seed( seed +2 )
y2 <- jitter(rep(1, totalNr), amount = 0.0001 * 1)
dfXmatrixIdent <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  all_imputation_methods, nProc = nProc)
library(opImputation)
seed = 100
nIter = 20
nProc = nProc <- round( ( parallel::detectCores( ) )  ) - 2
probMissing = 0.1
PValueThresholdForMetrics = 0.1
ImputationRepetitions = 20
Data = iris[,1:4]
PlotIt = TRUE
pfctMtdsInABC = FALSE
univariate_imputation_methods <- c( "median", "mean", "mode", "rSample" )
poisoned_imputation_methods <- c( "plus", "plusminus", "factor" )
calibrating_imputation_methods <- c("tinyNoise_0.000001", "tinyNoise_0.00001", "tinyNoise_0.0001", "tinyNoise_0.001", "tinyNoise_0.01",
"tinyNoise_0.05", "tinyNoise_0.1", "tinyNoise_0.2", "tinyNoise_0.5", "tinyNoise_1")
multivariate_imputation_methods <- c( "bag", "bag_repeated",
"rf_mice", "rf_mice_repeated", "rf_missForest", "rf_missForest_repeated", "miceRanger", "miceRanger_repeated",
"cart", "cart_repeated",
"linear",
"pmm", "pmm_repeated",
"knn3", "knn5", "knn7", "knn9", "knn10",
"ameliaImp", "ameliaImp_repeated",
"miImp"
)
all_imputation_methods <- c( univariate_imputation_methods,
poisoned_imputation_methods,
calibrating_imputation_methods,
multivariate_imputation_methods
)
ImputationMethods =all_imputation_methods
radius <- 5
totalNr <- 100
nVars <- 3
dfXmatrix <- NULL
jitterAmount <- 0.3
# "Two linear xy data sets forming an X" =
set.seed( seed )
x <- jitter( seq( from = 0, to = 10, length.out = totalNr ), amount = jitterAmount )
set.seed( seed + 1 )
y1 <- jitter( 1 * x, amount = jitterAmount )
set.seed( seed + 2 )
y2 <- jitter( -1 * x + 10, amount = jitterAmount )
dfXmatrixTwolinearXY <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# "UniformRandom3VarIndependent"
set.seed( seed )
x <- runif( totalNr, min = 0, max = 10 )
set.seed( seed + 1 )
y1 <- runif( totalNr, min = 0, max = 10 )
set.seed( seed + 2 )
y2 <- runif( totalNr, min = 0, max = 10 )
dfXmatrixIndependent <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# "UniformRandom3VarDependent" = {
set.seed( seed )
x <- runif( totalNr, min = 0, max = 10 )
set.seed( seed )
y1 <- runif( totalNr, min = 0, max = 10 )
set.seed( seed )
y2 <- runif( totalNr, min = 0, max = 10 )
dfXmatrixDependent <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# "AlmostIdenticalValues" = {
set.seed( seed )
x <- jitter(rep(1, totalNr), amount = 0.0001 * 1)
set.seed( seed + 1 )
y1 <- jitter(rep(1, totalNr), amount = 0.0001 * 1)
set.seed( seed +2 )
y2 <- jitter(rep(1, totalNr), amount = 0.0001 * 1)
dfXmatrixIdent <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# # Functions
#
# makeBadImputations <- function( x ) {
#   x[!is.na( x )] <- NA
#   return( data.frame( x ) )
# }
#
# # Calculate Groeneveld - Meeden skewness
# skewnessGM <- function( x ) {
#   x <- na.omit( x )
#   n <- length( x )
#   meanX <- mean( x, na.rm = TRUE )
#   medianX <- median( x, na.rm = TRUE )
#   Erw <- sum( abs( x - medianX ) ) / n
#   GM <- ( meanX - medianX ) / Erw
#   return( GM )
# }
#
# list.of.seeds <- 1:nIter + seed - 1
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  all_imputation_methods, nProc = nProc)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  all_imputation_methods, nProc = nProc)
apply(iris[,1:4], 2, function(x) sd(x/mean(x)))
TestImputationHepta <- opImputation(Data = data.frame(FCPS::Hepta$Data),
ImputationMethods =  c(all_imputation_methods), nProc = nProc)
apply(data.frame(FCPS::Hepta$Data), 2, function(x) sd(x/mean(x)))
library(opImputation)
TestImputationHepta <- opImputation(Data = data.frame(FCPS::Hepta$Data),
ImputationMethods =  all_imputation_methods, nProc = nProc, overallBestZDelta = TRUE)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  all_imputation_methods, nProc = nProc)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  all_imputation_methods, nProc = nProc)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  all_imputation_methods, nProc = nProc)
TestImputationHepta <- opImputation(Data = data.frame(FCPS::Hepta$Data),
ImputationMethods =  all_imputation_methods, nProc = nProc, overallBestZDelta = TRUE)
TestImputationHepta <- opImputation(Data = data.frame(FCPS::Hepta$Data),
ImputationMethods =  all_imputation_methods, nProc = nProc, overallBestZDelta = TRUE)
library(opImputation)
nProc = nProc <- round( ( parallel::detectCores( ) )  ) - 2
all_imputation_methods
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  all_imputation_methods, nProc = nProc)
nProc = nProc <- round( ( parallel::detectCores( ) )  ) - 2
nProc
library(opImputation)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  all_imputation_methods, nProc = nProc)
TestImputationIriscalibrating$Fig_zDeltaDistributions_bestMethods
library(opImputation)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  all_imputation_methods, nProc = nProc)
TestImputationIriscalibrating$Fig_zDeltaDistributions_bestMethods
TestImputationTwolinearXY <- opImputation(Data = dfXmatrixTwolinearXY,
ImputationMethods =  all_imputation_methods, nProc = nProc)
TestImputationRandomIndependent <- opImputation(Data = dfXmatrixIndependent,
ImputationMethods =  all_imputation_methods, nProc = nProc, overallBestzDelta = TRUE)
library(opImputation)
library(opImputation)
TestImputationHepta <- opImputation(Data = data.frame(FCPS::Hepta$Data),
ImputationMethods =  all_imputation_methods, nProc = nProc, overallBestzDelta = TRUE)
pic <- TestImputationHepta$FigABC
save(pic, file = "TestImputationHepta_FigABC.rdata")
nProc
nProc = nProc <- round( ( parallel::detectCores( ) )  ) - 2
library(opImputation)
nProc
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  all_imputation_methods, nProc = nProc)
TestImputationHepta <- opImputation(Data = data.frame(FCPS::Hepta$Data),
ImputationMethods =  all_imputation_methods, nProc = nProc, overallBestzDelta = TRUE)
pic <- TestImputationHepta$FigABC
save(pic, file = "TestImputationHepta_FigABC.rdata")
str_replace_all
stringr::str_replace_all
repList <- list(old = c("A", "B", "C", "D" ),
new = c(2,3,4,5))
)
repList <- list(old = c("A", "B", "C", "D" ),
new = c(2,3,4,5))
repList
a = c("A","A","A","C","D")
replaceString <- function(x, replaceList) {
which(x == replaceList)
}
replaceString(a, repList)
x == repList$old
a == repList$old
which(repList$old==a)
match(repList$old,a)
where <- match(repList$old,a)
repList$new[where]
where
where <- match(a, repList$old)
where
repList$new[where]
replaceString <- function(x, replaceList) {
where <- match(a, repList$old)
new <- repList$new[where]
return(new)
}
replaceString(a, repList)
repList <- list(old = c("A", "B", "C", "poisonedImputation" ),
new = myColorsABC[1:4])
# Constants, lists
univariate_imputation_methods <- c( "median", "mean", "mode", "rSample" )
poisoned_imputation_methods <- c( "plus", "plusminus", "factor" )
calibrating_imputation_methods <- c( "tinyNoise_0.000001", "tinyNoise_0.00001", "tinyNoise_0.0001", "tinyNoise_0.001", "tinyNoise_0.01",
"tinyNoise_0.05", "tinyNoise_0.1", "tinyNoise_0.2", "tinyNoise_0.5", "tinyNoise_1" )
multivariate_imputation_methods <- c( "bag", "bag_repeated",
"rf_mice", "rf_mice_repeated", "rf_missForest", "rf_missForest_repeated", "miceRanger", "miceRanger_repeated",
"cart", "cart_repeated",
"linear",
"pmm", "pmm_repeated",
"knn3", "knn5", "knn7", "knn9", "knn10",
"ameliaImp", "ameliaImp_repeated",
"miImp"
)
all_imputation_methods <- c( univariate_imputation_methods,
poisoned_imputation_methods,
calibrating_imputation_methods,
multivariate_imputation_methods
)
# Omit unnecessary notes for variables to plot
utils::globalVariables( c( "ABCx", "ABCy", "Category", "Failed", "Method", "color", "rSum", "value", "variable", "x", "x1", "xloc",
"y", "y1", "BestUnivariate", "Imputation", "Multivariate", "PDE", "label", "Methods" ) )
# Colors
myColorszDelta <- c( "#0072B2", "#009E73", "#D55E00", "#F0E442" )
myColorsABC <- c( "#009E73", "#56B4E9", "#E69F00", "red" )
repList <- list(old = c("A", "B", "C", "poisonedImputation" ),
new = myColorsABC[1:4])
repList
replaceString <- function(x, replaceList) {
where <- match(a, repList$old)
new <- repList$new[where]
return(new)
}
rep_list <- list(old = c("A", "B", "C", "poisonedImputation" ),
new = myColorsABC[1:4])
rep_list
library(opImputation)
nProc = nProc <- round( ( parallel::detectCores( ) )  ) - 2
all_imputation_methods
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  all_imputation_methods, nProc = nProc)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  all_imputation_methods, nProc = nProc)
