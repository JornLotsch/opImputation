labs( title = "ABC analysis of mean methods' ranks", x = "Fraction of rank sums", y = "Type of missing" )
library(opImputation)
library(opImputation)
TestImputationIrisPerfect <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, perfect_imputation_methods), nProc = nProc)
# Function to plot the ABC analysis results of the ranking of the imputation methods
makeABCanaylsis <- function( zABCvalues, HighlightPoisenedMethods = TRUE ) {
# Function to mark the ABC set membership of the items
ABCsetmembership <- function( x = NULL, ABCres = NULL, num = TRUE ) {
if ( is.null( ABCres ) ) {
ABCres <- ABCanalysis( x )
Ind <- seq_along( x )
} else {
Ind <- sort( c( ABCres$Aind, ABCres$Bind, ABCres$Cind ) )
}
Ind[ABCres$Aind] <- 1
Ind[ABCres$Bind] <- 2
Ind[ABCres$Cind] <- 3
if ( num == FALSE ) {
Ind <- LETTERS[Ind]
}
return( Ind )
}
# Function to prepare the data frame for the bar plot of the item ABC ZDelta values
ABCprepareResultsDF <- function( data, ABCres ) {
dfABC <- cbind.data.frame(
rSum = data,
Category = "C",
Method = names( data ),
xloc = 0:( length( data ) - 1 ) / ( length( data ) - 1 )
)
dfABC$Method <- gsub( ' imputed|Imp', '', dfABC$Method )
dfABC$Category <- ABCsetmembership( ABCres = ABCres, num = FALSE )
dfABC <- dfABC[with( dfABC, order( -rSum, Method ) ),]
dfABC$xloc <- sort( dfABC$xloc )
dfABC$Method <- factor( dfABC$Method, levels = dfABC$Method )
return( dfABC )
}
# Function to prepare the data frames for plotting the ABC curves and set limits
createABCxy <- function( ABCres ) {
ABCx <- ABCres$p
ABCy <- ABCres$ABC
return( data.frame(
ABCx = ABCx,
ABCy = ABCy
) )
}
createABCsetLimits <- function( ABCres ) {
return( data.frame(
x1 = ABCres$A[["Effort"]],
y1 = ABCres$A[["Yield"]],
x2 = ABCres$C[["Effort"]],
y2 = ABCres$C[["Yield"]]
) )
}
# Perform ABC analysis
ABCRanksumsInserted <- ABCanalysis( zABCvalues, PlotIt = FALSE )
# Make the data frames for the bar plot
dfABCcat <- ABCprepareResultsDF( data = zABCvalues, ABCres = ABCRanksumsInserted )
dfABCcat$Category1 <- dfABCcat$Category
dfABCcat$Category2 <- dfABCcat$Category
if ( HighlightPoisenedMethods ) {
dfABCcat$Category2[dfABCcat$Method %in% poisoned_imputation_methods] <- "poisonedImputation"
}
rep_str <- c(
"A" = myColorsABC[1],
"B" = myColorsABC[2],
"C" = myColorsABC[3],
"poisonedImputation" = myColorsABC[4]
)
names(myColorsABC) <- c("A", "B", "C", "poisonedImputation")
dfABCcat$Category1 <- stringr::str_replace_all( dfABCcat$Category1, rep_str )
dfABCcat$Category2 <- stringr::str_replace_all( dfABCcat$Category2, rep_str )
dfABCcat$poisoned <- ifelse( dfABCcat$Category2 == myColorsABC[4], myColorsABC[4], NA )
# Make the data frames for the line plot
dfABCxy <- createABCxy( ABCRanksumsInserted )
dfABCsetLimits <- createABCsetLimits( ABCRanksumsInserted )
# Make the ABC plot
ABCplot <-
ggplot( ) +
geom_bar( data = dfABCcat,
aes( x = xloc, y = rSum / max( rSum ), fill = Category1 ),
stat = "identity",
position = "dodge",
alpha = 0.5
) +
geom_line( data = dfABCxy, aes( x = ABCx, y = ABCy ), linewidth = 1 ) +
scale_x_continuous( breaks = unique( dfABCcat$xloc ), labels = levels( dfABCcat$Method ) ) +
geom_segment( data = dfABCsetLimits, aes( x = x1, y = -.01, xend = x1, yend = y1 ), linetype = "dashed", color = "grey33" ) +
geom_segment( data = dfABCsetLimits, aes( x = -.02, y = y1, xend = x1, yend = y1 ), linetype = "dashed", color = "grey33" ) +
geom_segment( data = dfABCsetLimits, aes( x = x2, y = -.01, xend = x2, yend = y2 ), linetype = "dashed", color = "grey33" ) +
geom_segment( data = dfABCsetLimits, aes( x = -.02, y = y2, xend = x2, yend = y2 ), linetype = "dashed", color = "grey33" ) +
theme_light( ) +
theme( axis.text.x = element_text( angle = 90, vjust = 0.5, hjust = 0 ),
legend.position = c( 0.9, 0.6 ),
legend.background = element_rect( fill = alpha( "white", 0.5 ) ) ) +
scale_y_continuous(
name = "Fraction of sum of largest rank means",
sec.axis = sec_axis( trans = ~. * max( dfABCcat$rSum ), name = "Rank mean" )
) +
scale_x_continuous( position = "top", expand = c( 0, 0 ) ) +
scale_x_continuous(
name = "Fraction of rank means", expand = c( 0, 0 ),
sec.axis = sec_axis( trans = ~. * 1, name = "Imputation method",
breaks = unique( dfABCcat$xloc ),
labels = unique( dfABCcat$Method ) )
) +
scale_fill_manual( values = myColorsABC[1:3] ) +
labs( title = "ABC analysis of mean methods' ranks", x = "Fraction of rank sums", y = "Type of missing", fill = "Category" )
# Return the plot
return( ABCplot = ABCplot )
}
library(opImputation)
TestImputationIrisPerfect <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, perfect_imputation_methods), nProc = nProc)
# Function to plot the ABC analysis results of the ranking of the imputation methods
makeABCanaylsis <- function( zABCvalues, HighlightPoisenedMethods = TRUE ) {
# Function to mark the ABC set membership of the items
ABCsetmembership <- function( x = NULL, ABCres = NULL, num = TRUE ) {
if ( is.null( ABCres ) ) {
ABCres <- ABCanalysis( x )
Ind <- seq_along( x )
} else {
Ind <- sort( c( ABCres$Aind, ABCres$Bind, ABCres$Cind ) )
}
Ind[ABCres$Aind] <- 1
Ind[ABCres$Bind] <- 2
Ind[ABCres$Cind] <- 3
if ( num == FALSE ) {
Ind <- LETTERS[Ind]
}
return( Ind )
}
# Function to prepare the data frame for the bar plot of the item ABC ZDelta values
ABCprepareResultsDF <- function( data, ABCres ) {
dfABC <- cbind.data.frame(
rSum = data,
Category = "C",
Method = names( data ),
xloc = 0:( length( data ) - 1 ) / ( length( data ) - 1 )
)
dfABC$Method <- gsub( ' imputed|Imp', '', dfABC$Method )
dfABC$Category <- ABCsetmembership( ABCres = ABCres, num = FALSE )
dfABC <- dfABC[with( dfABC, order( -rSum, Method ) ),]
dfABC$xloc <- sort( dfABC$xloc )
dfABC$Method <- factor( dfABC$Method, levels = dfABC$Method )
return( dfABC )
}
# Function to prepare the data frames for plotting the ABC curves and set limits
createABCxy <- function( ABCres ) {
ABCx <- ABCres$p
ABCy <- ABCres$ABC
return( data.frame(
ABCx = ABCx,
ABCy = ABCy
) )
}
# Perform ABC analysis
ABCRanksumsInserted <- ABCanalysis( zABCvalues, PlotIt = FALSE )
# Make the data frames for the bar plot
dfABCcat <- ABCprepareResultsDF( data = zABCvalues, ABCres = ABCRanksumsInserted )
dfABCcat$Category1 <- dfABCcat$Category
dfABCcat$Category2 <- dfABCcat$Category
if ( HighlightPoisenedMethods ) {
dfABCcat$Category2[dfABCcat$Method %in% poisoned_imputation_methods] <- "poisonedImputation"
}
rep_str <- c(
"A" = myColorsABC[1],
"B" = myColorsABC[2],
"C" = myColorsABC[3],
"poisonedImputation" = myColorsABC[4]
)
names(myColorsABC) <- c("A", "B", "C", "poisonedImputation")
dfABCcat$Category1 <- stringr::str_replace_all( dfABCcat$Category1, rep_str )
dfABCcat$Category2 <- stringr::str_replace_all( dfABCcat$Category2, rep_str )
dfABCcat$poisoned <- ifelse( dfABCcat$Category2 == myColorsABC[4], myColorsABC[4], NA )
# Make the data frames for the line plot
dfABCxy <- createABCxy( ABCRanksumsInserted )
# Make the ABC plot
ABCplot <-
ggplot( ) +
geom_bar( data = dfABCcat,
aes( x = xloc, y = rSum / max( rSum ), fill = Category1 ),
stat = "identity",
position = "dodge",
alpha = 0.5
) +
geom_line( data = dfABCxy, aes( x = ABCx, y = ABCy ), linewidth = 1 ) +
scale_x_continuous( breaks = unique( dfABCcat$xloc ), labels = levels( dfABCcat$Method ) ) +
theme_light( ) +
theme( axis.text.x = element_text( angle = 90, vjust = 0.5, hjust = 0 ),
legend.position = c( 0.9, 0.6 ),
legend.background = element_rect( fill = alpha( "white", 0.5 ) ) ) +
scale_y_continuous(
name = "Fraction of sum of largest rank means",
sec.axis = sec_axis( trans = ~. * max( dfABCcat$rSum ), name = "Rank mean" )
) +
scale_x_continuous( position = "top", expand = c( 0, 0 ) ) +
scale_x_continuous(
name = "Fraction of rank means", expand = c( 0, 0 ),
sec.axis = sec_axis( trans = ~. * 1, name = "Imputation method",
breaks = unique( dfABCcat$xloc ),
labels = unique( dfABCcat$Method ) )
) +
scale_fill_manual( values = myColorsABC[1:3] ) +
labs( title = "ABC analysis of mean methods' ranks", x = "Fraction of rank sums", y = "Type of missing", fill = "Category" )
# Return the plot
return( ABCplot = ABCplot )
}
library(opImputation)
TestImputationIrisPerfect <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, perfect_imputation_methods), nProc = nProc)
TestImputationHepta <- opImputation(Data = data.frame(FCPS::Hepta$Data),
ImputationMethods =  c(all_imputation_methods, perfect_imputation_methods), nProc = nProc, overallBestZDelta = TRUE)
pic <- TestImputationHepta$FigABC
save(pic, file = "TestImputationHepta_FigABC.rdata")
library(opImputation)
nIter
seed = 100
nIter = 20
nProc = nProc <- round( ( parallel::detectCores( ) )  ) - 2
probMissing = 0.1
PValueThresholdForMetrics = 0.1
ImputationRepetitions = 20
TestImputationIrisPerfect <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, perfect_imputation_methods), nProc = nProc)
univariate_imputation_methods <- c( "median", "mean", "mode", "rSample" )
poisoned_imputation_methods <- c( "plus", "plusminus", "factor" )
perfect_imputation_methods <- c("tinyNoise_0.000001", "tinyNoise_0.00001", "tinyNoise_0.0001", "tinyNoise_0.001", "tinyNoise_0.01",
"tinyNoise_0.05", "tinyNoise_0.1", "tinyNoise_0.2", "tinyNoise_0.5", "tinyNoise_1")
multivariate_imputation_methods <- c( "bag", "bag_repeated",
"rf_mice", "rf_mice_repeated", "rf_missForest", "rf_missForest_repeated", "miceRanger", "miceRanger_repeated",
"cart", "cart_repeated",
"linear",
"pmm", "pmm_repeated",
"knn3", "knn5", "knn7", "knn9", "knn10",
"ameliaImp", "ameliaImp_repeated",
"miImp"
)
all_imputation_methods <- c( univariate_imputation_methods,
poisoned_imputation_methods,
# perfect_imputation_methods,
multivariate_imputation_methods
)
library(opImputation)
ImputationMethods = c("rf_missForest", "median", "plus" )
seed = 100
nIter = 20
nProc = nProc <- round( ( parallel::detectCores( ) )  ) - 2
# probMissing = 0.1
# PValueThresholdForMetrics = 0.1
# ImputationRepetitions = 20
# Data = iris[,1:4]
# PlotIt = TRUE
# pfctMtdsInABC = FALSE
univariate_imputation_methods <- c( "median", "mean", "mode", "rSample" )
poisoned_imputation_methods <- c( "plus", "plusminus", "factor" )
calibrating_imputation_methods <- c("tinyNoise_0.000001", "tinyNoise_0.00001", "tinyNoise_0.0001", "tinyNoise_0.001", "tinyNoise_0.01",
"tinyNoise_0.05", "tinyNoise_0.1", "tinyNoise_0.2", "tinyNoise_0.5", "tinyNoise_1")
multivariate_imputation_methods <- c( "bag", "bag_repeated",
"rf_mice", "rf_mice_repeated", "rf_missForest", "rf_missForest_repeated", "miceRanger", "miceRanger_repeated",
"cart", "cart_repeated",
"linear",
"pmm", "pmm_repeated",
"knn3", "knn5", "knn7", "knn9", "knn10",
"ameliaImp", "ameliaImp_repeated",
"miImp"
)
all_imputation_methods <- c( univariate_imputation_methods,
poisoned_imputation_methods,
# calibrating_imputation_methods,
multivariate_imputation_methods
)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, calibrating_imputation_methods), nProc = nProc)
library(opImputation)
nProc
ImputationMethods = c("rf_missForest", "median", "plus" )
seed = 100
nIter = 20
nProc = nProc <- round( ( parallel::detectCores( ) )  ) - 2
# probMissing = 0.1
# PValueThresholdForMetrics = 0.1
# ImputationRepetitions = 20
# Data = iris[,1:4]
# PlotIt = TRUE
# pfctMtdsInABC = FALSE
univariate_imputation_methods <- c( "median", "mean", "mode", "rSample" )
poisoned_imputation_methods <- c( "plus", "plusminus", "factor" )
calibrating_imputation_methods <- c("tinyNoise_0.000001", "tinyNoise_0.00001", "tinyNoise_0.0001", "tinyNoise_0.001", "tinyNoise_0.01",
"tinyNoise_0.05", "tinyNoise_0.1", "tinyNoise_0.2", "tinyNoise_0.5", "tinyNoise_1")
multivariate_imputation_methods <- c( "bag", "bag_repeated",
"rf_mice", "rf_mice_repeated", "rf_missForest", "rf_missForest_repeated", "miceRanger", "miceRanger_repeated",
"cart", "cart_repeated",
"linear",
"pmm", "pmm_repeated",
"knn3", "knn5", "knn7", "knn9", "knn10",
"ameliaImp", "ameliaImp_repeated",
"miImp"
)
all_imputation_methods <- c( univariate_imputation_methods,
poisoned_imputation_methods,
# calibrating_imputation_methods,
multivariate_imputation_methods
)
radius <- 5
totalNr <- 100
nVars <- 3
dfXmatrix <- NULL
jitterAmount <- 0.3
# "Two linear xy data sets forming an X" =
set.seed( seed )
x <- jitter( seq( from = 0, to = 10, length.out = totalNr ), amount = jitterAmount )
set.seed( seed + 1 )
y1 <- jitter( 1 * x, amount = jitterAmount )
set.seed( seed + 2 )
y2 <- jitter( -1 * x + 10, amount = jitterAmount )
dfXmatrixTwolinearXY <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# "UniformRandom3VarIndependent"
set.seed( seed )
x <- runif( totalNr, min = 0, max = 10 )
set.seed( seed + 1 )
y1 <- runif( totalNr, min = 0, max = 10 )
set.seed( seed + 2 )
y2 <- runif( totalNr, min = 0, max = 10 )
dfXmatrixIndependent <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# "UniformRandom3VarDependent" = {
set.seed( seed )
x <- runif( totalNr, min = 0, max = 10 )
set.seed( seed )
y1 <- runif( totalNr, min = 0, max = 10 )
set.seed( seed )
y2 <- runif( totalNr, min = 0, max = 10 )
dfXmatrixDependent <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# "AlmostIdenticalValues" = {
set.seed( seed )
x <- jitter(rep(1, totalNr), amount = 0.0001 * 1)
set.seed( seed + 1 )
y1 <- jitter(rep(1, totalNr), amount = 0.0001 * 1)
set.seed( seed +2 )
y2 <- jitter(rep(1, totalNr), amount = 0.0001 * 1)
dfXmatrixIdent <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, calibrating_imputation_methods), nProc = nProc)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, calibrating_imputation_methods), nProc = nProc)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, calibrating_imputation_methods), nProc = nProc)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, calibrating_imputation_methods), nProc = nProc)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, calibrating_imputation_methods), nProc = nProc)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, calibrating_imputation_methods), nProc = nProc)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, calibrating_imputation_methods), nProc = nProc)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, calibrating_imputation_methods), nProc = nProc)
TestImputationTwolinearXY <- opImputation(Data = dfXmatrixTwolinearXY,
ImputationMethods =  c(all_imputation_methods, calibrating_imputation_methods), nProc = nProc)
TestImputationRandomIndependent <- opImputation(Data = dfXmatrixIndependent,
ImputationMethods =  c(all_imputation_methods, calibrating_imputation_methods), nProc = nProc, overallBestZDelta = TRUE)
TestImputationHepta <- opImputation(Data = data.frame(FCPS::Hepta$Data),
ImputationMethods =  c(all_imputation_methods, calibrating_imputation_methods), nProc = nProc, overallBestZDelta = TRUE)
pic <- TestImputationHepta$FigABC
save(pic, file = "TestImputationHepta_FigABC.rdata")
x
Data
Data = iris[,1:4]
x = Data
x <- data.frame( x )
if ( is.null( seed ) ) {
seed <- .Random.seed[1]
}
list.of.seeds <- seq_len( ncol( x ) ) + seed - 1
set.seed( seed )
list.of.seeds
iImputedData <- lapply( list.of.seeds, function( s ) {
set.seed( s )
Impu <- try( caret::preProcess( x, method = "bagImpute" ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- predict( Impu, x )
}
return( ImputedData = ImputedData )
} )
iImputedData
all.matrix <- abind::abind( ImputedData, along = 3 )
all.matrix <- abind::abind( iImputedData, along = 3 )
all.matrix
ImputedDataXAverage <- data.frame( apply( all.matrix, c( 1, 2 ), function( x ) mean( x, na.rm = TRUE ) ) )
ImputedDataXAverage
library(opImputation)
seed = 100
nIter = 20
nProc = nProc <- round( ( parallel::detectCores( ) )  ) - 2
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, calibrating_imputation_methods), nProc = nProc)
univariate_imputation_methods <- c( "median", "mean", "mode", "rSample" )
poisoned_imputation_methods <- c( "plus", "plusminus", "factor" )
calibrating_imputation_methods <- c("tinyNoise_0.000001", "tinyNoise_0.00001", "tinyNoise_0.0001", "tinyNoise_0.001", "tinyNoise_0.01",
"tinyNoise_0.05", "tinyNoise_0.1", "tinyNoise_0.2", "tinyNoise_0.5", "tinyNoise_1")
multivariate_imputation_methods <- c( "bag", "bag_repeated",
"rf_mice", "rf_mice_repeated", "rf_missForest", "rf_missForest_repeated", "miceRanger", "miceRanger_repeated",
"cart", "cart_repeated",
"linear",
"pmm", "pmm_repeated",
"knn3", "knn5", "knn7", "knn9", "knn10",
"ameliaImp", "ameliaImp_repeated",
"miImp"
)
all_imputation_methods <- c( univariate_imputation_methods,
poisoned_imputation_methods,
# calibrating_imputation_methods,
multivariate_imputation_methods
)
TestImputationIriscalibrating <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, calibrating_imputation_methods), nProc = nProc)
library(opImputation)
library(opImputation)
univariate_imputation_methods <- c( "median", "mean", "mode", "rSample" )
poisoned_imputation_methods <- c( "plus", "plusminus", "factor" )
calibrating_imputation_methods <- c("tinyNoise_0.000001", "tinyNoise_0.00001", "tinyNoise_0.0001", "tinyNoise_0.001", "tinyNoise_0.01",
"tinyNoise_0.05", "tinyNoise_0.1", "tinyNoise_0.2", "tinyNoise_0.5", "tinyNoise_1")
multivariate_imputation_methods <- c( "bag", "bag_repeated",
"rf_mice", "rf_mice_repeated", "rf_missForest", "rf_missForest_repeated", "miceRanger", "miceRanger_repeated",
"cart", "cart_repeated",
"linear",
"pmm", "pmm_repeated",
"knn3", "knn5", "knn7", "knn9", "knn10",
"ameliaImp", "ameliaImp_repeated",
"miImp"
)
all_imputation_methods <- c( univariate_imputation_methods,
poisoned_imputation_methods,
calibrating_imputation_methods,
multivariate_imputation_methods
)
radius <- 5
totalNr <- 100
nVars <- 3
dfXmatrix <- NULL
jitterAmount <- 0.3
# "Two linear xy data sets forming an X" =
set.seed( seed )
##########  Test whole function #######################################
ImputationMethods = c("rf_missForest", "median", "plus" )
seed = 100
nIter = 20
nProc = nProc <- round( ( parallel::detectCores( ) )  ) - 2
# probMissing = 0.1
# PValueThresholdForMetrics = 0.1
# ImputationRepetitions = 20
# Data = iris[,1:4]
# PlotIt = TRUE
# pfctMtdsInABC = FALSE
univariate_imputation_methods <- c( "median", "mean", "mode", "rSample" )
poisoned_imputation_methods <- c( "plus", "plusminus", "factor" )
calibrating_imputation_methods <- c("tinyNoise_0.000001", "tinyNoise_0.00001", "tinyNoise_0.0001", "tinyNoise_0.001", "tinyNoise_0.01",
"tinyNoise_0.05", "tinyNoise_0.1", "tinyNoise_0.2", "tinyNoise_0.5", "tinyNoise_1")
multivariate_imputation_methods <- c( "bag", "bag_repeated",
"rf_mice", "rf_mice_repeated", "rf_missForest", "rf_missForest_repeated", "miceRanger", "miceRanger_repeated",
"cart", "cart_repeated",
"linear",
"pmm", "pmm_repeated",
"knn3", "knn5", "knn7", "knn9", "knn10",
"ameliaImp", "ameliaImp_repeated",
"miImp"
)
all_imputation_methods <- c( univariate_imputation_methods,
poisoned_imputation_methods,
calibrating_imputation_methods,
multivariate_imputation_methods
)
radius <- 5
totalNr <- 100
nVars <- 3
dfXmatrix <- NULL
jitterAmount <- 0.3
# "Two linear xy data sets forming an X" =
set.seed( seed )
x <- jitter( seq( from = 0, to = 10, length.out = totalNr ), amount = jitterAmount )
set.seed( seed + 1 )
y1 <- jitter( 1 * x, amount = jitterAmount )
set.seed( seed + 2 )
y2 <- jitter( -1 * x + 10, amount = jitterAmount )
dfXmatrixTwolinearXY <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# "UniformRandom3VarIndependent"
set.seed( seed )
x <- runif( totalNr, min = 0, max = 10 )
set.seed( seed + 1 )
y1 <- runif( totalNr, min = 0, max = 10 )
set.seed( seed + 2 )
y2 <- runif( totalNr, min = 0, max = 10 )
dfXmatrixIndependent <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# "UniformRandom3VarDependent" = {
set.seed( seed )
x <- runif( totalNr, min = 0, max = 10 )
set.seed( seed )
y1 <- runif( totalNr, min = 0, max = 10 )
set.seed( seed )
y2 <- runif( totalNr, min = 0, max = 10 )
dfXmatrixDependent <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# "AlmostIdenticalValues" = {
set.seed( seed )
x <- jitter(rep(1, totalNr), amount = 0.0001 * 1)
set.seed( seed + 1 )
y1 <- jitter(rep(1, totalNr), amount = 0.0001 * 1)
set.seed( seed +2 )
y2 <- jitter(rep(1, totalNr), amount = 0.0001 * 1)
dfXmatrixIdent <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
TestImputationHepta <- opImputation(Data = data.frame(FCPS::Hepta$Data),
ImputationMethods =  all_imputation_methods, nProc = nProc, overallBestZDelta = TRUE)
