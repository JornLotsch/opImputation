rBiasMx = rBiasinsertedMissings,
pfctMtdsInABC = pfctMtdsInABC,
nIter = nIter )
# Return results
return( list(
BestPerDatasetRanksums_insertedMissings = CombinedMetricsInsertedMissings[["BestPerDatasetRanksums_Missings"]],
BestUnivariatePerDatasetRanksums_insertedMissings = CombinedMetricsInsertedMissings[["BestUnivariatePerDatasetRanksums_Missings"]],
BestMultivariatePerDatasetRanksums_insertedMissings = CombinedMetricsInsertedMissings[["BestMultivariatePerDatasetRanksums_Missings"]],
BestUniMultivariatePerDatasetRanksums_insertedMissings = CombinedMetricsInsertedMissings[["BestUniMultivariatePerDatasetRanksums_Missings"]],
BestPoisonedPerDatasetRanksums_insertedMissings = CombinedMetricsInsertedMissings[["BestPoisonedPerDatasetRanksums_Missings"]],
BestPerDatasetRanksums_insertedMissings = CombinedMetricsInsertedMissings[["BestPerDatasetRanksums_Missings"]],
BestPerDatasetRanksums_insertedMissings = CombinedMetricsInsertedMissings[["BestPerDatasetRanksums_Missings"]],
BestRanksumsGrandMean_insertedMissings_ABC_A = CombinedMetricsInsertedMissings[["BestRanksumsGrandMean_Missings_ABC_A"]],
ranksumsErrorsInsertedMissings = CombinedMetricsInsertedMissings[["ranksumsErrorsMissings"]],
grandMeanrankErrorsInsertedMissings = CombinedMetricsInsertedMissings[["grandMeanrankErrorsMissings"]],
RMSEinsertedMissings = RMSEinsertedMissings,
MEinsertedMissings = MEinsertedMissings,
rBiasinsertedMissings = rBiasinsertedMissings,
ranksRMSEinsertedMissings = CombinedMetricsInsertedMissings[["RRMSEMX"]],
ranksMEinsertedMissings = CombinedMetricsInsertedMissings[["RMEMx"]],
ranksrBiasinsertedMissings = CombinedMetricsInsertedMissings[["RrBiasMx"]],
PerDatasetRanksums_insertedMissings = CombinedMetricsInsertedMissings[["PerDatasetRanksums_Missings"]],
zABCvalues_insertedMissings = CombinedMetricsInsertedMissings[["zABCvalues"]]
) )
}
# Find best imputation
MethodsResults <- findBestMethod(
RepeatedSampleImputations = RepeatedSampleImputations,
pfctMtdsInABC = pfctMtdsInABC,
nIter = nIter
)
BestMethodPerDataset <- gsub( " imputed|Imp", "", MethodsResults$BestPerDatasetRanksums_insertedMissings )
BestUnivariateMethodPerDataset <- gsub( " imputed|Imp", "", MethodsResults$BestUnivariatePerDatasetRanksums_insertedMissings )
BestMultivariateMethodPerDataset <- gsub( " imputed|Imp", "", MethodsResults$BestMultivariatePerDatasetRanksums_insertedMissings )
BestUniMultivariateMethodPerDataset <- gsub( " imputed|Imp", "", MethodsResults$BestUniMultivariatePerDatasetRanksums_insertedMissings )
BestPoisonedMethodPerDataset <- gsub( " imputed|Imp", "", MethodsResults$BestPoisonedPerDatasetRanksums_insertedMissings )
# Retrieve imputed data
ImputedData <- retrieveAveragedImputedData(
Data = Data,
RepeatedSampleImputations = RepeatedSampleImputations
)
# Look at imputation accuracies
Zdeltas <- retrieveZdeltas( RepeatedSampleImputations = RepeatedSampleImputations )
# Helper function for data frame creation for bar plot
generateBarPlotDataFrames <- function( data, BestUniMultivariateMethodPerDataset,
minmax, annotate_methods, imputation_methods ) {
df <- data.frame( reshape2::melt( data ) )
df$Method <- gsub( " imputed|Imp", "", rownames( df ) )
MethodsOrder <- df$Method[order( df$value )]
df$Method <- factor( df$Method, levels = MethodsOrder )
df$Failed <- ifelse( is.na( df$value ), 0.01, NA )
df$color <- "Multivariate"
df$color[df$Method %in% gsub( " imputed", "", poisoned_imputation_methods )] <- "Poisened"
df$color[df$Method %in% gsub( " imputed", "", univariate_imputation_methods )] <- "Univariate"
df$color[df$Method %in% gsub( " imputed", "", perfect_imputation_methods )] <- "Perfect"
df$color <- factor( df$color, levels = c( "Multivariate", "Perfect", "Poisened", "Univariate" ) )
names( myColorsZDelta ) <- levels( df$color )
df$perfectMtd <- ifelse( df$color == "Perfect", "Perfect methods", "Methods" )
df$perfectMtd <- factor( df$perfectMtd, levels = c( "Perfect methods", "Methods" ) )
if ( minmax == "min" ) {
minmaxPoisened <- min( df$value[df$color %in% "Poisened"], na.rm = TRUE )
minmaxUnivariate <- min( df$value[df$color %in% "Univariate"], na.rm = TRUE )
dfAnnotate <- data.frame( Methods = annotate_methods,
y = c( minmaxPoisened, minmaxUnivariate, df$value[df$Method == BestUniMultivariateMethodPerDataset] ),
x = c( 3, 3, 2 ),
color = c( "salmon", "orange", "darkgreen" ) )
} else {
minmaxPoisened <- max( df$value[df$color %in% "Poisened"], na.rm = TRUE )
minmaxUnivariate <- max( df$value[df$color %in% "Univariate"], na.rm = TRUE )
dfAnnotate <- data.frame( Methods = annotate_methods,
y = c( minmaxPoisened, minmaxUnivariate, 0.4 ),
x = 3,
color = c( "salmon", "orange", "darkgreen" ) )
}
return( list(
dfBars = df,
dfAnnotate = dfAnnotate,
myColorsZDelta = myColorsZDelta
)
)
}
# Helper function for data frame creation for PDE plot
generatePDEPlotDataFrames <- function( multivarZDeltas, univarZDeltas, poisonedZDeltas, perfectZDeltas ) {
vZDeltas <- c( multivarZDeltas, univarZDeltas, poisonedZDeltas, perfectZDeltas )
namesvZDeltas <- c( rep( "Multivariate", length( multivarZDeltas ) ),
rep( "Univariate", length( univarZDeltas ) ),
rep( "Poisened", length( poisonedZDeltas ) ),
rep( "Perfect", length( perfectZDeltas ) ) )
df4plot_long <- cbind.data.frame( Category = namesvZDeltas, Zdelta = vZDeltas )
df4plot_long <- na.omit( df4plot_long )
# Calculate PDE xy
ParetoDistributions <- lapply( unique( df4plot_long$Category ), function( Category ) {
Pareto <- DataVisualizations::ParetoDensityEstimation( Data = df4plot_long$Zdelta[df4plot_long$Category == Category], PlotIt = FALSE )
dfPareto <- data.frame( Category = Category, x = Pareto$kernels, PDE = Pareto$paretoDensity )
return( dfPareto )
} )
dfParetoAll <- do.call( rbind.data.frame, ParetoDistributions )
dfParetoAll$Category <- factor( dfParetoAll$Category, levels = c( "Multivariate", "Perfect", "Poisened", "Univariate" ) )
return( dfParetoAll )
}
# Function to create a bare ZDealta bar plot
createBarplot <- function( data, BestUniMultivariateMethodPerDataset,
minmax, title, ylab, annotate_methods ) {
# Data frame creation
df <- generateBarPlotDataFrames(
data = data,
BestUniMultivariateMethodPerDataset = BestUniMultivariateMethodPerDataset,
minmax = minmax,
annotate_methods = annotate_methods
)
df4plot_long <- df$dfBars
dfAnnotate <- df$dfAnnotate
myColorsZDelta <- df$myColorsZDelta
# Plotting
BarplotMeans <-
ggplot( data = df4plot_long, aes( x = Method, y = value ) ) +
geom_bar( aes( fill = color ), stat = "identity", position = "dodge", alpha = 0.5 ) +
ggh4x::facet_grid2( . ~ perfectMtd, scales = "free", space = "free_x", independent = "y" ) +
theme_light( ) +
theme(
axis.text.x = element_text( angle = 90, vjust = 0.5, hjust = 1 ),
legend.position = c( 0.9, 0.7 ),
legend.background = element_rect( fill = alpha( "white", 0.5 ) )
) +
labs( title = title, y = ylab, x = NULL, fill = "Imputation" ) +
scale_y_continuous( breaks = scales::pretty_breaks( ) ) +
scale_fill_manual( values = myColorsZDelta ) +
geom_hline( yintercept = dfAnnotate$y[1], color = "salmon", linetype = "dashed" ) +
geom_hline( yintercept = dfAnnotate$y[2], color = "orange", linetype = "dotdash" ) +
geom_hline( yintercept = dfAnnotate$y[3], color = "darkgreen" ) +
geom_text( data = dfAnnotate, aes( label = Methods, x = x, y = y, color = color ), label.size = 0.15, inherit.aes = FALSE ) +
scale_color_manual( values = myColorsZDelta )
if ( !sum( is.na( df4plot_long$Failed ) ) == nrow( df4plot_long ) ) {
BarplotMeans <- BarplotMeans + geom_point( aes( x = Method, y = Failed ), pch = 4 )
}
return( BarplotMeans )
}
# Function to create a bare ZDelta PDE plot
createZDeltaPDEplots <- function( dfParetoAll ) {
names( myColorsZDelta ) <- levels( dfParetoAll$Category )
PDERawZDeltas <-
ggplot( ) +
geom_line( data = dfParetoAll[dfParetoAll$Category %in% c( "Multivariate", "Univariate" ),], aes( x = x, y = PDE, color = Category ) ) +
theme_light( ) +
theme(
legend.position = "bottom",
legend.direction = "horizontal",
legend.background = element_rect( colour = "transparent", fill = ggplot2::alpha( "white", 0.4 ) )
) +
labs( title = "PDE of raw Zdelta values", x = "Data", y = "PDE" ) +
scale_color_manual( values = myColorsZDelta )
return( PDERawZDeltas )
}
# Main functions
# Function to create a bar plot of mean Zdelta values from iterations
createBarplotMeanZDeltas <-
function( meanImputationZDeltaInsertedMissings, BestUniMultivariateMethodPerDataset ) {
rowmeanImputationZDeltaInsertedMissings <- apply( meanImputationZDeltaInsertedMissings, 1, function( x ) median( x, na.rm = TRUE ) )
BarplotMeanZDeltas <- createBarplot( data = rowmeanImputationZDeltaInsertedMissings,
BestUniMultivariateMethodPerDataset,
minmax = "min",
title = "zDelta (means)",
ylab = "zDelta",
annotate_methods = c( "Best poisoned", "Best univariate", "Best" ) ) +
scale_y_continuous( trans = "log10" )
return( BarplotMeanZDeltas )
}
# Function to create a bar plot of mean GMC values from iterations
createBarplotMeanGMCs <-
function( ImputationZDeltaInsertedMissingsRaw  ) {
dfImputationZDeltaInsertedMissingsRaw <- do.call( cbind.data.frame, ImputationZDeltaInsertedMissingsRaw )
GMCImputationZDeltaInsertedMissings <- apply( dfImputationZDeltaInsertedMissingsRaw, 1, function( x ) skewnessGM( as.vector( x ) ) )
BarplotMeanGMC <- createBarplot( data = GMCImputationZDeltaInsertedMissings,
minmax = "max",
title = "GMC (means)",
ylab = "GMC",
annotate_methods = c( "Best poisoned", "Best univariate", "GMC limit" ) )
BarplotMeanGMC <- BarplotMeanGMC + geom_hline( yintercept = 0.4, color = "darkgreen" )
return( BarplotMeanGMC )
}
# Function to create a sina plot of raw Zdelta values
createZDeltasPerVarPlot <- function( meanImputationZDeltaInsertedMissings ) {
rowmeanImputationZDeltaInsertedMissings <- apply( meanImputationZDeltaInsertedMissings, 1, function( x ) median( x, na.rm = TRUE ) )
df <- data.frame( reshape2::melt( rowmeanImputationZDeltaInsertedMissings ) )
df$Method <- gsub( " imputed|Imp", "", rownames( df ) )
MethodsOrder <- df$Method[order( df$value )]
zDeltaP <- data.frame( meanImputationZDeltaInsertedMissings )
zDeltaP$Method <- gsub( ' imputed|Imp', '', rownames( zDeltaP ) )
zDeltaP$Method <- factor( zDeltaP$Method, levels = MethodsOrder )
zDeltaP$perfectMtd <- ifelse( zDeltaP$Method %in% perfect_imputation_methods, "Perfect methods", "Methods" )
zDeltaP$perfectMtd <- factor( zDeltaP$perfectMtd, levels = c( "Perfect methods", "Methods" ) )
zDelta_long <- reshape2::melt( zDeltaP )
zDelta_long$variable <- gsub( "ZDelta_", "", zDelta_long$variable )
zDelta_long$Failed <- ifelse( is.na( zDelta_long$value ), 0.01, NA )
ZDeltaPerVarPlot <-
ggplot( data = zDelta_long, aes( x = Method, y = value, color = variable ) ) +
geom_violin( ) +
geom_jitter( width = 0.05 ) +
ggh4x::facet_grid2( . ~ perfectMtd, scales = "free", space = "free_x", independent = "y" ) +
theme_light( ) +
theme( axis.text.x = element_text( angle = 90, vjust = 0.5, hjust = 1 ),
legend.position = "top", legend.direction = "horizontal",
legend.background = element_rect( fill = alpha( "white", 0.5 ) ) ) +
labs( title = "Mean ZDelta per variable", x = NULL, y = "Normalized error", color = "Variable" ) +
# stat_summary( aes( y = value, ymax = after_stat( y ), ymin = after_stat( y ) ),
#               fun = median, geom = "errorbar", color = "red", width = 0.3 ) +
guides( colour = guide_legend( nrow = 1 ) ) +
scale_y_continuous( trans = "log10" )
if ( !sum( is.na( zDelta_long$Failed ) ) == nrow( zDelta_long ) ) {
ZDeltaPerVarPlot <- ZDeltaPerVarPlot + geom_point( aes( x = Method, y = Failed ), pch = 4, color = "black" )
}
return( ZDeltaPerVarPlot )
}
# Create ZDelta plots
pZdeltasPlotAvgerage <- createBarplotMeanZDeltas(
meanImputationZDeltaInsertedMissings = Zdeltas$meanImputationZDeltaInsertedMissings,
BestUniMultivariateMethodPerDataset = BestUniMultivariateMethodPerDataset
)
pZdeltasPerVar <- createZDeltasPerVarPlot(
meanImputationZDeltaInsertedMissings = Zdeltas$meanImputationZDeltaInsertedMissings
)
# Function to plot the ABC analysis results of the ranking of the imputation methods
makeABCanaylsis <- function( zABCvalues, zDelta = NULL, HighlightPoisenedMethods = TRUE ) {
ABCsetmembership <- function( x = NULL, ABCres = NULL, num = TRUE ) {
if ( is.null( ABCres ) ) {
ABCres <- ABCanalysis( x )
Ind <- seq_along( x )
} else {
Ind <- sort( c( ABCres$Aind, ABCres$Bind, ABCres$Cind ) )
}
Ind[ABCres$Aind] <- 1
Ind[ABCres$Bind] <- 2
Ind[ABCres$Cind] <- 3
if ( num == FALSE ) {
Ind <- LETTERS[Ind]
}
return( Ind )
}
ABCanalysisWrapper <- function( data ) {
ABCanalysis( data, PlotIt = FALSE )
}
ABCRanksumsInserted <- ABCanalysisWrapper( zABCvalues )
ABCprepareResultsDF <- function( data, ABCres ) {
dfABC <- cbind.data.frame(
rSum = data,
Category = "C",
Method = names( data ),
xloc = 0:( length( data ) - 1 ) / ( length( data ) - 1 )
)
dfABC$Method <- gsub( ' imputed|Imp', '', dfABC$Method )
dfABC$Category <- ABCsetmembership( ABCres = ABCres, num = FALSE )
dfABC <- dfABC[with( dfABC, order( -rSum, Method ) ),]
dfABC$xloc <- sort( dfABC$xloc )
dfABC$Method <- factor( dfABC$Method, levels = dfABC$Method )
return( dfABC )
}
dfABCcat <- ABCprepareResultsDF( data = zABCvalues, ABCres = ABCRanksumsInserted )
dfABCcat$Category1 <- dfABCcat$Category
dfABCcat$Category2 <- dfABCcat$Category
if ( HighlightPoisenedMethods ) {
dfABCcat$Category2[dfABCcat$Method %in% poisoned_imputation_methods] <- "poisonedImputation"
}
rep_str <- c(
"A" = myColorsABC[1],
"B" = myColorsABC[2],
"C" = myColorsABC[3],
"poisonedImputation" = myColorsABC[4]
)
dfABCcat$Category1 <- stringr::str_replace_all( dfABCcat$Category1, rep_str )
dfABCcat$Category2 <- stringr::str_replace_all( dfABCcat$Category2, rep_str )
dfABCcat$poisoned <- ifelse( dfABCcat$Category2 == myColorsABC[4], myColorsABC[4], NA )
createABCxy <- function( ABCres ) {
ABCx <- ABCres$p
ABCy <- ABCres$ABC
return( data.frame(
ABCx = ABCx,
ABCy = ABCy
) )
}
createABCsetLimits <- function( ABCres ) {
return( data.frame(
x1 = ABCres$B[["Effort"]],
y1 = ABCres$B[["Yield"]],
x2 = ABCres$C[["Effort"]],
y2 = ABCres$C[["Yield"]]
) )
}
dfABCxy <- createABCxy( ABCRanksumsInserted )
dfABCsetLimits <- createABCsetLimits( ABCRanksumsInserted )
ABCplot <- ggplot( ) +
geom_bar( data = dfABCcat,
aes( x = xloc, y = rSum / max( dfABCcat$rSum ), fill = dfABCcat$Category1 ),
stat = "identity",
position = "dodge",
alpha = 0.5
) +
geom_line( data = dfABCxy, aes( x = ABCx, y = ABCy ), linewidth = 1 ) +
scale_x_continuous( breaks = unique( dfABCcat$xloc ), labels = levels( dfABCcat$Method ) ) +
geom_segment( data = dfABCsetLimits, aes( x = x1, y = -.01, xend = x1, yend = y1 ), linetype = "dashed", color = "grey33" ) +
geom_segment( data = dfABCsetLimits, aes( x = -.02, y = y1, xend = x1, yend = y1 ), linetype = "dashed", color = "grey33" ) +
theme_light( ) +
theme( axis.text.x = element_text( angle = 90, vjust = 0.5, hjust = 0 ),
legend.position = c( 0.9, 0.6 ),
legend.background = element_rect( fill = alpha( "white", 0.5 ) ) ) +
scale_y_continuous(
name = "Fraction of sum of largest rank means",
sec.axis = sec_axis( trans = ~. * max( dfABCcat$rSum ), name = "Rank mean" )
) +
scale_x_continuous( position = "top", expand = c( 0, 0 ) ) +
scale_x_continuous(
name = "Fraction of rank means", expand = c( 0, 0 ),
sec.axis = sec_axis( trans = ~. * 1, name = "Imputation method",
breaks = unique( dfABCcat$xloc ),
labels = unique( dfABCcat$Method ) )
) +
scale_fill_identity( name = "Category",
labels = c( "A", "B", "C" ),
breaks = myColorsABC[1:3],
guide = "legend" ) +
labs( title = "ABC analysis of mean methods' ranks", x = "Fraction of rank sums", y = "Type of missing" )
return( ABCplot = ABCplot )
}
# Create ABC plots
pABC <- makeABCanaylsis(
zABCvalues = MethodsResults$zABCvalues_insertedMissings
)
# Function to combine p-values
fisher_method <- function( p_values ) {
p_values <- pmax( pmin( p_values, 1 ), 0 )
chi_squared_statistic <- -2 * sum( log( p_values ) )
degrees_of_freedom <- 2 * length( p_values )
combined_p_value <- 1 - pchisq( chi_squared_statistic, df = degrees_of_freedom )
return( combined_p_value )
}
# Function to find best method per category
retrieveZDeltasForBestMethodPerCategory <- function( Zdeltas,
BestMethodPerDataset, BestUnivariateMethodPerDataset,
BestMultivariateMethodPerDataset, BestUniMultivariateMethodPerDataset, BestPoisonedMethodPerDataset ) {
multivarZDeltas <- unlist( lapply( Zdeltas$ImputationZDeltaInsertedMissings, function( x )
x[gsub( " imputed|Imp", "", rownames( x ) ) %in% BestMultivariateMethodPerDataset,] ) )
univarZDeltas <- unlist( lapply( Zdeltas$ImputationZDeltaInsertedMissings, function( x )
x[gsub( " imputed|Imp", "", rownames( x ) ) %in% BestUnivariateMethodPerDataset,] ) )
if ( BestMethodPerDataset %in% poisoned_imputation_methods ) {
univarZDeltas <- unlist( lapply( Zdeltas$ImputationZDeltaInsertedMissings, function( x )
x[gsub( " imputed|Imp", "", rownames( x ) ) %in% BestPoisonedMethodPerDataset,] ) )
} else {
poisonedZDeltas <- NULL
}
return( list( multivarZDeltas = multivarZDeltas,
univarZDeltas = univarZDeltas,
poisonedZDeltas = poisonedZDeltas ) )
}
# Function to create a PDE plot of Zdelta values for best methods
createpZdeltasMultivarUnivarPDE <- function( Zdeltas,
BestMethodPerDataset, BestUnivariateMethodPerDataset,
BestMultivariateMethodPerDataset, BestUniMultivariateMethodPerDataset, BestPoisonedMethodPerDataset ) {
# Retrieve ZDeltas for best method per per category
BestZDeltas <- retrieveZDeltasForBestMethodPerCategory( Zdeltas,
BestMethodPerDataset, BestUnivariateMethodPerDataset,
BestMultivariateMethodPerDataset, BestUniMultivariateMethodPerDataset, BestPoisonedMethodPerDataset )
multivarZDeltas <- BestZDeltas$multivarZDeltas
univarZDeltas <- BestZDeltas$univarZDeltas
poisonedZDeltas <- BestZDeltas$poisonedZDeltas
# Create PDE plot
dfParetoAll <- generatePDEPlotDataFrames( multivarZDeltas = multivarZDeltas,
univarZDeltas = univarZDeltas,
poisonedZDeltas = poisonedZDeltas,
perfectZDeltas = NULL
)
PDERawZDeltasBest <- createZDeltaPDEplots( dfParetoAll = dfParetoAll )
PDERawZDeltasBest <- PDERawZDeltasBest +
labs( title = "PDE of raw Zdelta (best uni/multivariate)" )
# Do stats multivariate versus univariate imputation errors
df.stat.deltas <- rbind.data.frame(
cbind.data.frame( y = 1, x = univarZDeltas ),
cbind.data.frame( y = 2, x = multivarZDeltas )
)
stat.deltas.W <- wilcox.test( df.stat.deltas$x ~ df.stat.deltas$y )$p.value
# stat.deltas.CDF <- ks.test( univarZDeltas, multivarZDeltas )$p.value
stat.deltas.CDF <- twosamples::dts_test( univarZDeltas, multivarZDeltas )["P-Value"]
stat.deltas <- fisher_method( p_values = c( stat.deltas.W, stat.deltas.CDF ) )
# Creating a data frame for statistical tests
dfStats <- data.frame(
Test = c( "Wilcoxon test", "DTS test", "Combination of tests" ),
pValue = c( stat.deltas.W, stat.deltas.CDF, stat.deltas ),
x = 0.5 * max( dfParetoAll$x ),
y = 1
)
dfStats$label <- paste0( dfStats$Test, ": ", formatC( dfStats$pValue, format = "e", digits = 4 ) )
if ( BestMethodPerDataset %in% poisoned_imputation_methods ) {
dfStats <- rbind.data.frame(
dfStats,
data.frame( Test = NA, pValue = NA, x = 0.5 * max( dfParetoAll$x ), y = NA,
label = "A poisoned method is best!" )
)
PDERawZDeltasBest <- PDERawZDeltasBest +
geom_line( data = dfParetoAll[dfParetoAll$Category %in% c( "Perfect", "Poisened" ),],
aes( x = x,
y = PDE / max( dfParetoAll$PDE[dfParetoAll$Category %in% c( "Perfect", "Poisened" )] ) *
max( dfParetoAll$PDE[dfParetoAll$Category %in% c( "Multivariate", "Univariate" )] ), color = Category ) ) +
scale_y_continuous(
name = "PDE (univariate, multivariate)",
sec.axis = sec_axis( trans = ~. * max( dfParetoAll$PDE[dfParetoAll$Category %in% c( "Perfect", "Poisened" )] ) /
max( dfParetoAll$PDE[dfParetoAll$Category %in% c( "Multivariate", "Univariate" )] ), name = "PDE (poisened / perfect)" )
)
}
# Finalize plot labels
dfStats$y <- seq( from = 0.95, by = -0.05, length.out = nrow( dfStats ) ) *
max( dfParetoAll$PDE[dfParetoAll$Category %in% c( "Multivariate", "Univariate" )] )
PDERawZDeltasBest <- PDERawZDeltasBest +
geom_text( data = dfStats, aes( label = label, x = x, y = y ), inherit.aes = FALSE )
return( PDERawZDeltasBest )
}
# Function to create a QQ plot of Zdelta values for best methods
createpZdeltasMultivarUnivarQQ <- function( Zdeltas,
BestMethodPerDataset, BestUnivariateMethodPerDataset,
BestMultivariateMethodPerDataset, BestUniMultivariateMethodPerDataset, BestPoisonedMethodPerDataset ) {
# Retrieve ZDeltas for best method per per category
BestZDeltas <- retrieveZDeltasForBestMethodPerCategory( Zdeltas,
BestMethodPerDataset, BestUnivariateMethodPerDataset,
BestMultivariateMethodPerDataset, BestUniMultivariateMethodPerDataset, BestPoisonedMethodPerDataset )
multivarZDeltas <- BestZDeltas$multivarZDeltas
univarZDeltas <- BestZDeltas$univarZDeltas
poisonedZDeltas <- BestZDeltas$poisonedZDeltas
# QQ plots
quantiles <- seq( 0, 1, 0.01 )
df_quantiles <- cbind.data.frame(
BestUnivariate = quantile( univarZDeltas, quantiles, na.rm = TRUE ),
Multivariate = quantile( multivarZDeltas, quantiles, na.rm = TRUE )
)
p_qq <-
ggplot( data = df_quantiles, aes( x = BestUnivariate, y = Multivariate ) ) +
geom_point( color = "dodgerblue", alpha = 0.6 ) +
geom_abline( aes( slope = 1, intercept = 0 ), linetype = 2, color = "salmon" ) +
theme_light( ) +
theme( legend.position = c( 0.1, 0.9 ),
strip.background = element_rect( fill = "cornsilk" ),
strip.text = element_text( colour = "black" ) ) +
labs( title = "QQ plot raw Zdelta (best methods)" ) +
xlim( 0, 1 ) +
ylim( 0, 1 )
return( p_qq )
}
pZdeltasMultivarUnivarPDE <-
createpZdeltasMultivarUnivarPDE( Zdeltas = Zdeltas,
BestMethodPerDataset = BestMethodPerDataset,
BestUnivariateMethodPerDataset = BestUnivariateMethodPerDataset,
BestMultivariateMethodPerDataset = BestMultivariateMethodPerDataset,
BestUniMultivariateMethodPerDataset = BestUniMultivariateMethodPerDataset,
BestPoisonedMethodPerDataset = BestPoisonedMethodPerDataset )
library(opImputation)
library(opImputation)
TestImputationIrisPerfect <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, perfect_imputation_methods), nProc = nProc)
TestImputationIrisPerfect <- opImputation(Data = iris[,1:4],
ImputationMethods =  c(all_imputation_methods, perfect_imputation_methods), nProc = nProc)
# "Two linear xy data sets forming an X" =
set.seed( seed )
x <- jitter( seq( from = 0, to = 10, length.out = totalNr ), amount = jitterAmount )
set.seed( seed + 1 )
y1 <- jitter( 1 * x, amount = jitterAmount )
set.seed( seed + 2 )
y2 <- jitter( -1 * x + 10, amount = jitterAmount )
dfXmatrixTwolinearXY <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# "UniformRandom3VarIndependent"
set.seed( seed )
x <- runif( totalNr, min = 0, max = 10 )
set.seed( seed + 1 )
y1 <- runif( totalNr, min = 0, max = 10 )
set.seed( seed + 2 )
y2 <- runif( totalNr, min = 0, max = 10 )
dfXmatrixIndependent <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# "UniformRandom3VarDependent" = {
set.seed( seed )
x <- runif( totalNr, min = 0, max = 10 )
set.seed( seed )
y1 <- runif( totalNr, min = 0, max = 10 )
set.seed( seed )
y2 <- runif( totalNr, min = 0, max = 10 )
dfXmatrixDependent <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
# "AlmostIdenticalValues" = {
set.seed( seed )
x <- jitter(rep(1, totalNr), amount = 0.0001 * 1)
set.seed( seed + 1 )
y1 <- jitter(rep(1, totalNr), amount = 0.0001 * 1)
set.seed( seed )
y2 <- jitter(rep(1, totalNr), amount = 0.0001 * 1)
dfXmatrixIdent <- cbind.data.frame( Var1 = x, Var2 = y1, Var3 = y2 )
TestImputationTwolinearXY <- opImputation(Data = dfXmatrixTwolinearXY,
ImputationMethods =  c(all_imputation_methods, perfect_imputation_methods), nProc = nProc)
TestImputationTwolinearXY <- opImputation(Data = dfXmatrixTwolinearXY,
ImputationMethods =  c(all_imputation_methods, perfect_imputation_methods), nProc = nProc)
TestImputationTwolinearXY <- opImputation(Data = dfXmatrixTwolinearXY,
ImputationMethods =  c(all_imputation_methods, perfect_imputation_methods), nProc = nProc)
TestImputationTwolinearXY <- opImputation(Data = dfXmatrixTwolinearXY,
ImputationMethods =  c(all_imputation_methods, perfect_imputation_methods), nProc = nProc)
TestImputationRandomIndependent <- opImputation(Data = dfXmatrixIndependent,
ImputationMethods =  c(all_imputation_methods, perfect_imputation_methods), nProc = nProc)
library(opImputation)
TestImputationRandomIndependent <- opImputation(Data = dfXmatrixIndependent,
ImputationMethods =  c(all_imputation_methods, perfect_imputation_methods), nProc = nProc)
TestImputationHepta <- opImputation(Data = data.frame(FCPS::Hepta$Data),
ImputationMethods =  c(all_imputation_methods, perfect_imputation_methods), nProc = nProc)
poisonedZDeltas
univarZDeltas
multivarZDeltas <- unlist( lapply( Zdeltas$ImputationZDeltaInsertedMissings, function( x )
x[gsub( " imputed|Imp", "", rownames( x ) ) %in% BestMultivariateMethodPerDataset,] ) )
multivarZDeltas
citation(caret)
citation("caret")
citation("cvms")
citation("corrplot")
