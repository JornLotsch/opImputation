ImputedData <- Impu$imputations[[1]]
}
},
ameliaImp_repeated = {
set.seed( seed )
Impu <- try( eval_with_timeout( Amelia::amelia.default( x, m = imputationRepetitions ), timeout = 30 ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
iImputedData <- Impu$imputations
ImputedData <- Reduce( "+", iImputedData ) / length( iImputedData )
}
},
miImp = {
Impu <- try( mi::mi( x, verbose = FALSE, parallel = FALSE ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
iImputedData <- mi::complete( Impu )
ImputedDataMI <- Reduce( "+", iImputedData ) / length( iImputedData )
ImputedData <- ImputedDataMI[, names( x )]
}
},
# from here, noise and nonsense imputations for use in the experiments
plusminus = {
fac <- seq_len( nrow( x_orig ) )
ImputedData <- apply( x_orig, 2, function( x_orig ) x_orig + ( -1 )^fac * 0.2 * median( x_orig, na.rm = TRUE ) )
},
plus = {
ImputedData <- apply( x_orig, 2, function( x_orig ) x_orig + 1 * 0.2 * median( x_orig, na.rm = TRUE ) )
},
factorImp = {
ImputedData <- apply( x_orig, 2, function( x_orig ) x_orig * ( 1 + 0.03 * median( x_orig, na.rm = TRUE ) ) )
}
)
# final error intercepting, if necessary
if ( !method %in% nonsense_imputation_methods ) {
err <- try( ImputedData - x, TRUE )
if ( inherits( err, "try-error" ) | sum( is.na( ImputedData ) ) > 0 ) {
ImputedData <- makeBadImputations( x )
}
}
return( ImputedData )
}
# Impute data set
ImputedDataAll <- imputeData( dfMtx = dfXmatrixInsertedMissings,
dfMtxorig = dfXmatrix,
ImputationMethods = ImputationMethods,
imputationRepetitions = imputationRepetitions,
seed = seed,
nProc = nProc)
ImputedDataAll
library(opImputation)
TestImputation2X <- opImputation(Data = iris[,1:4],
ImputationMethods =  c("rf2", "median", "mean", "mode", "plus" ))
TestImputation2X
Data = iris[,1:4]
ImputationMethods =  c("rf2", "median", "mean", "mode", "plus" )
list.of.seeds
list.of.seeds=c(1,2,3)
nProc = 2
probMissing = 0.1
imputationRepetitions = 20
# Impute data sets
RepeatedSampleImputations <- makeAndMeasureRepeatedImputations(
Data = Data,
seeds = list.of.seeds,
probMissing = probMissing,
nProc = nProc,
ImputationMethods = ImputationMethods,
imputationRepetitions = imputationRepetitions
)
RepeatedSampleImputations
# Function to impute data matrices with missing values
imputeData <- function( dfMtx, dfMtxorig, ImputationMethods, imputationRepetitions, seed, nProc) {
parallel::mclapply( ImputationMethods, function( method ) {
dfXmatriximputed <- cbind.data.frame( Data = paste0( method, " imputed" ), makeBadImputations( dfMtx ) )
dfXmatriximputed_list <- data.frame( imputeMissings( x = dfMtx, method = method, imputationRepetitions = imputationRepetitions, seed = seed, x_orig = dfMtxorig, nProc = nProc ) )
if ( identical( dim( dfXmatriximputed_list ), dim( dfMtx ) ) ) {
dfXmatriximputed <- cbind.data.frame( Data = paste0( method, " imputed" ), dfXmatriximputed_list )
}
return( dfXmatriximputed )
}, mc.cores = nProc )
}
# Function to calculate metrics for the imputations
makeMetricsMatrix <- function( OrigData, Missings_Which, ImputedData, Metric, OrigDataMiss = NULL ) {
data.frame( do.call(
cbind,
lapply( seq_along( Missings_Which ), function( i ) {
by( ImputedData, list( ImputedData$Data ), function( y ) {
OrigDataMiss_i <- if ( !is.null( OrigDataMiss ) ) OrigDataMiss[, i]
calculateMetrics(
OrigData = OrigData[, i],
Missings_Which = Missings_Which[[i]],
ImputedData = within( y, rm( Data ) )[, i],
Metric = Metric,
OrigDataMiss = OrigDataMiss_i
)
} )
} )
) )
}
dfXmatrix <- Data
dfXmatrixInitialMissings_Which <- lapply( seq_along( Data ), function( i ) which( is.na( Data[, i] ) ) )
dfXmatrixInsertedMissings_WhichAndData <- createMissings( x = dfXmatrix, Prob = probMissing, seed = seed, mnarity = 0, lowOnly = F, mnarshape = 1 )
# Function to insert missing values in complete data sets
createMissings <- function( x, Prob = 0.1, mnarity = 0, mnarshape = 1, lowOnly = FALSE, seed = NULL ) {
xm <- as.matrix( x )
if ( is.null( seed ) ) {
seed <- .Random.seed[1]
}
list.of.seeds <- seq_len( ncol( xm ) ) + seed - 1
toDeleteM <- lapply( seq_len( ncol( xm ) ), function( i ) {
set.seed( list.of.seeds[i] )
x_actual <- xm[, i]
x_actual_copy <- ifelse( is.na( x_actual ), 0, x_actual )
probabilitiesLarge <- abs( x_actual_copy ) / sum( abs( x_actual_copy ) )
probabilitiesSmall <- 1 - abs( x_actual_copy ) / sum( abs( x_actual_copy ) )
if ( !lowOnly ) {
probabilitiesNAR <- apply( cbind.data.frame( probabilitiesLarge, probabilitiesSmall ), 1, max ) * mnarity
} else {
probabilitiesNAR <- probabilitiesSmall * mnarity
}
probabilitiesNAR <- probabilitiesNAR^( 1 / mnarshape )
if ( mnarity != 0 ) {
probabilitiesNAR <- probabilitiesNAR / sum( probabilitiesNAR )
}
probabilitiesAR <- rep( 1 / length( x_actual_copy ), length( x_actual_copy ) ) * ( 1 - mnarity )
probabilities <- apply( cbind.data.frame( probabilitiesNAR, probabilitiesAR ), 1, sum )
probabilities <- probabilities / sum( probabilities )
NonNAs <- which( !is.na( x_actual ) )
toDelete <- sample( NonNAs, size = Prob * length( x_actual ), prob = probabilities[NonNAs], replace = FALSE )
return( toDelete )
} )
v_toDelete <- unlist( toDeleteM )
allDel <- names( which( table( v_toDelete ) == ncol( xm ) ) )
for ( i in 1:100000 ) {
if ( length( allDel ) > 0 ) {
v_toDelete[v_toDelete %in% allDel] <- NA
v_toDelete[is.na( v_toDelete )] <- sample( seq_len( nrow( xm ) ), sum( is.na( v_toDelete ) ), replace = FALSE )
allDel <- names( which( table( v_toDelete ) == ncol( xm ) ) )
} else {
break
}
}
istop <- c( 0, cumsum( unlist( lapply( toDeleteM, length ) ) ) )
toDelete2 <- lapply( seq_along( toDeleteM ), function( i ) v_toDelete[( istop[i] + 1 ):( istop[i + 1] )] )
toDelete2 <- lapply( toDelete2, unique )
for ( i in seq_len( ncol( xm ) ) ) {
toDeleteC <- toDelete2[[i]]
xm[toDeleteC, i] <- NA
}
dfxm <- data.frame( xm )
return( list( toDelete = toDelete2, missData = dfxm ) )
}
dfXmatrix <- Data
dfXmatrixInitialMissings_Which <- lapply( seq_along( Data ), function( i ) which( is.na( Data[, i] ) ) )
dfXmatrixInsertedMissings_WhichAndData <- createMissings( x = dfXmatrix, Prob = probMissing, seed = seed, mnarity = 0, lowOnly = F, mnarshape = 1 )
seed=1
dfXmatrix <- Data
dfXmatrixInitialMissings_Which <- lapply( seq_along( Data ), function( i ) which( is.na( Data[, i] ) ) )
dfXmatrixInsertedMissings_WhichAndData <- createMissings( x = dfXmatrix, Prob = probMissing, seed = seed, mnarity = 0, lowOnly = F, mnarshape = 1 )
iNA <- 1
MaxNAs <- max( apply( dfXmatrixInsertedMissings_WhichAndData$missData, 1, function( x ) sum( is.na( x ) ) ) )
while ( MaxNAs == ncol( dfXmatrixInsertedMissings_WhichAndData$missData ) ) {
dfXmatrixInsertedMissings_WhichAndData <- createMissings( x = dfXmatrix, Prob = probMissing, seed = seed + 1000000 * iNA, mnarity = 0, lowOnly = F, mnarshape = 1 )
MaxNAs <- max( apply( dfXmatrixInsertedMissings_WhichAndData$missData, 1, function( x ) sum( is.na( x ) ) ) )
iNA <- iNA + 1
}
dfXmatrixInsertedMissings <- dfXmatrixInsertedMissings_WhichAndData$missData
dfXmatrixInsertedMissings_Which <- lapply( seq_along( dfXmatrixInsertedMissings_WhichAndData$toDelete ), function( i ) setdiff( dfXmatrixInsertedMissings_WhichAndData$toDelete[[i]], dfXmatrixInitialMissings_Which[[i]] ) )
ImputedDataAll <- imputeData( dfMtx = dfXmatrixInsertedMissings,
dfMtxorig = dfXmatrix,
ImputationMethods = ImputationMethods,
imputationRepetitions = imputationRepetitions,
seed = seed,
nProc = nProc)
ImputedDataAll
imputeData <- function( dfMtx, dfMtxorig, ImputationMethods, imputationRepetitions, seed, nProc) {
makeBadImputations <- function( x ) {
x[!is.na( x )] <- NA
return( data.frame( x ) )
}
parallel::mclapply( ImputationMethods, function( method ) {
dfXmatriximputed <- cbind.data.frame( Data = paste0( method, " imputed" ), makeBadImputations( dfMtx ) )
dfXmatriximputed_list <- data.frame( imputeMissings( x = dfMtx, method = method, imputationRepetitions = imputationRepetitions, seed = seed, x_orig = dfMtxorig, nProc = nProc ) )
if ( identical( dim( dfXmatriximputed_list ), dim( dfMtx ) ) ) {
dfXmatriximputed <- cbind.data.frame( Data = paste0( method, " imputed" ), dfXmatriximputed_list )
}
return( dfXmatriximputed )
}, mc.cores = nProc )
}
ImputedDataAll <- imputeData( dfMtx = dfXmatrixInsertedMissings,
dfMtxorig = dfXmatrix,
ImputationMethods = ImputationMethods,
imputationRepetitions = imputationRepetitions,
seed = seed,
nProc = nProc)
ImputedDataAll
#################################### Libraries ########################################################################
library( caret )
library( missForest )
library( mice )
library( miceRanger )
library( multiUS )
library( Amelia )
library( mi )
#################################### Functions ########################################################################
# Main imputation method selection
imputeMissings <- function( x, method = "rf2", imputationRepetitions = 10,
seed = NULL, x_orig = NULL, nProc = 1,
nonsense_imputation_methods = c( "plus", "plusminus", "factor" )
) {
# Helper functions
imputeMedian <- function( x ) {
x <- as.numeric( as.character( x ) )
x[is.na( x )] <- median( x, na.rm = TRUE )
return( x )
}
imputeMean <- function( x ) {
x <- as.numeric( as.character( x ) )
x[is.na( x )] <- mean( x, na.rm = TRUE )
return( x )
}
getMode <- function( v ) {
v <- na.omit( v )
uniqv <- unique( v )
mode <- uniqv[which.max( tabulate( match( v, uniqv ) ) )]
return( mode )
}
imputeMode <- function( x ) {
x <- as.numeric( as.character( x ) )
x[is.na( x )] <- getMode( x )
return( x )
}
imputeRandom <- function( x ) {
x <- as.numeric( as.character( x ) )
x[is.na( x )] <- sample( na.omit( x ), replace = TRUE )
return( x )
}
makeBadImputations <- function( x ) {
x[!is.na( x )] <- NA
return( data.frame( x ) )
}
# Imputation
x <- data.frame( x )
if ( is.null( seed ) ) {
seed <- .Random.seed[1]
}
list.of.seeds <- seq_len( ncol( x ) ) + seed - 1
set.seed( seed )
ImputedData <- makeBadImputations( x )
switch(
method,
median = ImputedData <- apply( x, 2, imputeMedian ),
mean = ImputedData <- apply( x, 2, imputeMean ),
mode = ImputedData <- apply( x, 2, imputeMode ),
rSample = ImputedData <- apply( x, 2, imputeRandom ),
bag = {
Impu <- try( caret::preProcess( x, method = "bagImpute" ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- predict( Impu, x )
}
},
bag_repeated = {
iImputedData <- parallel::mclapply( list.of.seeds, function( s ) {
set.seed( s )
Impu <- try( caret::preProcess( x, method = "bagImpute" ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- predict( Impu, x )
}
return( ImputedData = ImputedData )
}, mc.cores = nProc )
ImputedData <- Reduce( "+", iImputedData ) / length( iImputedData )
},
rf = {
Impu <- try( mice::mice( x, method = "rf", print = FALSE ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- mice::complete( Impu )
}
},
rf_repeated = {
iImputedData <- parallel::mclapply( list.of.seeds, function( s ) {
set.seed( s )
Impu <- try( mice::mice( x, method = "rf" ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- mice::complete( Impu )
}
return( ImputedData = ImputedData )
}, mc.cores = nProc )
ImputedData <- Reduce( "+", iImputedData ) / length( iImputedData )
},
rf2 = {
Impu <- try( missForest::missForest( x ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- Impu$ximp
}
},
rf2_repeated = {
iImputedData <- parallel::mclapply( list.of.seeds, function( s ) {
set.seed( s )
Impu <- try( missForest::missForest( x ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- Impu$ximp
}
return( ImputedData = ImputedData )
}, mc.cores = nProc )
ImputedData <- Reduce( "+", iImputedData ) / length( iImputedData )
},
miceRanger = {
miceObj <- miceRanger::miceRanger( x, 1, 1, returnModels = TRUE, verbose = FALSE )
Impu <- try( miceRanger::impute( x, miceObj ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- data.frame( Impu$imputedData[[1]] )
}
},
miceRanger_repeated = {
iImputedData <- parallel::mclapply( list.of.seeds, function( s ) {
set.seed( s )
miceObj <- miceRanger::miceRanger( x, 1, 1, returnModels = TRUE, verbose = FALSE )
Impu <- try( miceRanger::impute( x, miceObj ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- data.frame( Impu$imputedData[[1]] )
}
return( ImputedData = ImputedData )
}, mc.cores = nProc )
ImputedData <- Reduce( "+", iImputedData ) / length( iImputedData )
},
cart = {
Impu <- try( mice::mice( x, method = "cart", print = FALSE ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- mice::complete( Impu )
}
},
cart_repeated = {
iImputedData <- parallel::mclapply( list.of.seeds, function( s ) {
set.seed( s )
Impu <- try( mice::mice( x, method = "cart" ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- mice::complete( Impu )
}
return( ImputedData = ImputedData )
}, mc.cores = nProc )
ImputedData <- Reduce( "+", iImputedData ) / length( iImputedData )
},
linear = {
Impu <- try( mice::mice( x, method = "lasso.norm", print = FALSE ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- mice::complete( Impu )
}
},
pmm = {
Impu <- try( mice::mice( x, method = "pmm" ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- mice::complete( Impu )
}
},
pmm_repeated = {
iImputedData <- parallel::mclapply( list.of.seeds, function( s ) {
set.seed( s )
Impu <- try( mice::mice( x, method = "pmm" ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- mice::complete( Impu )
}
return( ImputedData = ImputedData )
}, mc.cores = nProc )
ImputedData <- Reduce( "+", iImputedData ) / length( iImputedData )
},
knn3 = {
Impu <- try( multiUS::KNNimp( x, k = 3 ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- Impu
}
},
knn5 = {
Impu <- try( multiUS::KNNimp( x, k = 5 ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- Impu
}
},
knn7 = {
Impu <- try( multiUS::KNNimp( x, k = 7 ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- Impu
}
},
knn9 = {
Impu <- try( multiUS::KNNimp( x, k = 9 ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- Impu
}
},
knn10 = {
Impu <- try( multiUS::KNNimp( x ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- Impu
} else {
ImputedData <- makeBadImputations( x )
}
},
ameliaImp = {
set.seed( seed )
Impu <- try( eval_with_timeout( Amelia::amelia.default( x ), timeout = 30 ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
ImputedData <- Impu$imputations[[1]]
}
},
ameliaImp_repeated = {
set.seed( seed )
Impu <- try( eval_with_timeout( Amelia::amelia.default( x, m = imputationRepetitions ), timeout = 30 ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
iImputedData <- Impu$imputations
ImputedData <- Reduce( "+", iImputedData ) / length( iImputedData )
}
},
miImp = {
Impu <- try( mi::mi( x, verbose = FALSE, parallel = FALSE ), TRUE )
if ( !inherits( Impu, "try-error" ) ) {
iImputedData <- mi::complete( Impu )
ImputedDataMI <- Reduce( "+", iImputedData ) / length( iImputedData )
ImputedData <- ImputedDataMI[, names( x )]
}
},
# from here, noise and nonsense imputations for use in the experiments
plusminus = {
fac <- seq_len( nrow( x_orig ) )
ImputedData <- apply( x_orig, 2, function( x_orig ) x_orig + ( -1 )^fac * 0.2 * median( x_orig, na.rm = TRUE ) )
},
plus = {
ImputedData <- apply( x_orig, 2, function( x_orig ) x_orig + 1 * 0.2 * median( x_orig, na.rm = TRUE ) )
},
factorImp = {
ImputedData <- apply( x_orig, 2, function( x_orig ) x_orig * ( 1 + 0.03 * median( x_orig, na.rm = TRUE ) ) )
}
)
# final error intercepting, if necessary
if ( !method %in% nonsense_imputation_methods ) {
err <- try( ImputedData - x, TRUE )
if ( inherits( err, "try-error" ) | sum( is.na( ImputedData ) ) > 0 ) {
ImputedData <- makeBadImputations( x )
}
}
return( ImputedData )
}
ImputedDataAll <- imputeData( dfMtx = dfXmatrixInsertedMissings,
dfMtxorig = dfXmatrix,
ImputationMethods = ImputationMethods,
imputationRepetitions = imputationRepetitions,
seed = seed,
nProc = nProc)
ImputedDataAll
library(opImputation)
TestImputation2X <- opImputation(Data = iris[,1:4],
ImputationMethods =  c("rf2", "median", "mean", "mode", "plus" ))
library(opImputation)
TestImputation2X <- opImputation(Data = iris[,1:4],
ImputationMethods =  c("rf2", "median", "mean", "mode", "plus" ))
library(opImputation)
TestImputation2X <- opImputation(Data = iris[,1:4],
ImputationMethods =  c("rf2", "median", "mean", "mode", "plus" ))
library(opImputation)
TestImputation2X <- opImputation(Data = iris[,1:4],
ImputationMethods =  c("rf2", "median", "mean", "mode", "plus" ))
library(opImputation)
TestImputation2X <- opImputation(Data = iris[,1:4],
ImputationMethods =  c("rf2", "median", "mean", "mode", "plus" ))
library(opImputation)
TestImputation2X <- opImputation(Data = iris[,1:4],
ImputationMethods =  c("rf2", "median", "mean", "mode", "plus" ))
library(opImputation)
TestImputation2X <- opImputation(Data = iris[,1:4],
ImputationMethods =  c("rf2", "median", "mean", "mode", "plus" ))
library(opImputation)
TestImputation2X <- opImputation(Data = iris[,1:4],
ImputationMethods =  c("rf2", "median", "mean", "mode", "plus" ))
library(opImputation)
TestImputation2X <- opImputation(Data = iris[,1:4],
ImputationMethods =  c("rf2", "median", "mean", "mode", "plus" ))
createPDERawZDeltas
multivarZDeltas
??mnarity
Prob = 0.1
x = c(1,2,3,4,5)
xm <- as.matrix( x )
if ( is.null( seed ) ) {
seed <- .Random.seed[1]
}
seed <- .Random.seed[1]
list.of.seeds <- seq_len( ncol( xm ) ) + seed - 1
set.seed( list.of.seeds[i] )
i=1
set.seed( list.of.seeds[i] )
x_actual <- xm[, i]
x_actual_copy <- ifelse( is.na( x_actual ), 0, x_actual )
probabilitiesLarge <- abs( x_actual_copy ) / sum( abs( x_actual_copy ) )
probabilitiesSmall <- 1 - abs( x_actual_copy ) / sum( abs( x_actual_copy ) )
if ( !lowOnly ) {
probabilitiesNAR <- apply( cbind.data.frame( probabilitiesLarge, probabilitiesSmall ), 1, max ) * mnarity
} else {
probabilitiesNAR <- probabilitiesSmall * mnarity
}
probabilitiesNAR <- apply( cbind.data.frame( probabilitiesLarge, probabilitiesSmall ), 1, max ) * mnarity
mnarity = 0
probabilitiesNAR <- apply( cbind.data.frame( probabilitiesLarge, probabilitiesSmall ), 1, max ) * mnarity
probabilitiesNAR
probabilitiesNAR <- probabilitiesNAR^( 1 / mnarshape )
mnarity = 0.1
probabilitiesNAR <- apply( cbind.data.frame( probabilitiesLarge, probabilitiesSmall ), 1, max ) * mnarity
probabilitiesNAR
probabilitiesNAR <- probabilitiesNAR^( 1 / mnarshape )
mnarshape = 1
probabilitiesNAR <- probabilitiesNAR^( 1 / mnarshape )
probabilitiesNAR
mnarshape = 2
probabilitiesNAR <- probabilitiesNAR^( 1 / mnarshape )
probabilitiesNAR
